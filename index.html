<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>VibeChat(Œ±) | Multi-branch LLM WebChat</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Doto:wght@100..900&display=swap" rel="stylesheet">
    <link href="https://fastly.jsdelivr.net/npm/bootstrap@5.3.8/dist/css/bootstrap.min.css" rel="stylesheet">
    <script src="https://fastly.jsdelivr.net/npm/bootstrap@5.3.8/dist/js/bootstrap.bundle.min.js"></script>
    <script src="https://fastly.jsdelivr.net/npm/marked/marked.min.js"></script>
    
    <style>
        :root {
            --bg-color: #f8f9fa;
            --sidebar-bg: #343a40;
            --text-color: #212529;
            --node-bg: white;
            --border-color: #dee2e6;
            --primary-color: #007bff;
            --success-color: #28a745;
            --info-color: #6f42c1;
            --shadow: 0 3px 10px rgba(0,0,0,0.1);
        }

        [data-theme="dark"] {
            --bg-color: #121212;
            --sidebar-bg: #1a1a1a;
            --text-color: #e9ecef;
            --node-bg: #2d2d2d;
            --border-color: #444;
            --primary-color: #0d6efd;
            --success-color: #198754;
            --info-color: #6f42c1;
            --shadow: 0 3px 10px rgba(0,0,0,0.3);
        }

        body {
            font-family: 'Microsoft Yahei UI', 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background-color: var(--bg-color);
            color: var(--text-color);
            overflow: hidden;
            margin: 0;
            padding: 0;
            transition: background-color 0.3s, color 0.3s;
        }
        
        .vibe-font { font-family: 'Doto', sans-serif; font-weight: 300; }
        .container-fluid { height: 100vh; padding: 0; }
        .sidebar { background-color: var(--sidebar-bg); color: white; height: 100vh; overflow-y: auto; }
        .editor-container { position: relative; height: 100vh; overflow: hidden; background-color: var(--bg-color); display: flex; flex-direction: column; padding: 0 !important; }
        .story-canvas-container { position: relative; width: 100%; flex: 1; overflow: auto; }
        .story-canvas { position: relative; width: 5000px; height: 5000px; background-color: var(--bg-color); background-image: linear-gradient(var(--border-color) 1px, transparent 1px), linear-gradient(90deg, var(--border-color) 1px, transparent 1px); background-size: 20px 20px; transform-origin: 0 0; transition: transform 0.1s ease; }
        .node { position: absolute; width: 450px; background-color: var(--node-bg); border-radius: 8px; box-shadow: var(--shadow); padding: 15px; cursor: move; transition: all 0.2s; z-index: 10; padding: .5rem !important; }
        .node.selected { box-shadow: 0 0 0 2px var(--primary-color), 0 5px 15px rgba(0,0,0,0.2); z-index: 20; }
        .node.muted { opacity: 0.4; background-color: var(--bg-color); }
        .node.system { border-left: 5px solid var(--success-color); height: 150px; }
        .node.user { border-left: 5px solid var(--primary-color); height: 150px; }
        .node.assistant { border-left: 5px solid var(--info-color); height: 250px; }
        .node-content { font-size: 14px; margin-bottom: 0; border: 1px dashed var(--border-color); padding: 8px; border-radius: 4px; word-break: break-word; overflow-y: auto; height: calc(100% - 25px); }
        .connections { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; z-index: 5; }
        .tree-view { list-style-type: none; padding-left: 0; min-width: 200px; overflow-x: auto; }
        .tree-view ul { list-style-type: none; padding-left: 20px; }
        .tree-node { padding: 5px 10px; cursor: pointer; border-radius: 4px; margin-bottom: 2px; min-width: 200px; font-size: .75em; }
        .tree-node:hover { background-color: rgba(255, 255, 255, 0.1); }
        .tree-node.selected { background-color: var(--primary-color); }
        .zoom-controls, .toolbar { position: absolute; top: 20px; z-index: 100; }
        .zoom-controls { right: 20px; }
        .toolbar { left: 20px; display: flex; gap: 5px; }
        .chat-input-container { background-color: var(--node-bg); padding: 25px; border-top: 1px solid var(--border-color); z-index: 100; flex-shrink: 0; }
        .api-settings { padding: 4px 4px; }
        .role-indicator { font-size: 10px; font-weight: bold; padding: 2px 6px; border-radius: 10px; margin-bottom: 5px; display: inline-block; }
        .role-system { background-color: var(--success-color); color: white; }
        .role-user { background-color: var(--primary-color); color: white; }
        .role-assistant { background-color: var(--info-color); color: white; }
        .typing-indicator { display: inline-block; width: 10px; height: 10px; background-color: #6c757d; border-radius: 50%; margin-right: 5px; animation: typing 1s infinite; }
        @keyframes typing { 0%, 100% { opacity: 0.3; } 50% { opacity: 1; } }
        .reasoning-content { background-color: var(--bg-color); border: 1px solid var(--border-color); border-radius: 4px; padding: 8px; margin-bottom: 8px; font-size: 13px; color: #6c757d; max-height: 120px; overflow-y: auto; }
        .reasoning-toggle { font-size: 12px; color: #6c757d; cursor: pointer; user-select: none; margin-bottom: 5px; display: inline-block; }
        .reasoning-toggle:hover { color: #495057; }
        .reasoning-collapsed { max-height: 55px; overflow: hidden; }
        .reasoning-collapsed::after { content: "..."; display: block; text-align: center; color: #adb5bd; }
        .resend-btn, .copy-btn { position: absolute; top: 5px; background: rgba(255, 255, 255, 0.9); border: 1px solid var(--border-color); border-radius: 4px; padding: 2px 6px; font-size: 10px; cursor: pointer; z-index: 15; opacity: 0; transition: opacity 0.2s; }
        .copy-btn { right: 5px; }
        .resend-btn { right: 30px; }
        .node:hover .resend-btn, .node:hover .copy-btn { opacity: 1; }
        .resend-btn:hover { background-color: var(--primary-color); color: white; }
        .copy-btn:hover { background-color: var(--success-color); color: white; }
        .copy-success { position: absolute; top: 5px; left: 50%; transform: translateX(-50%); background-color: #0dcaf0; color: white; padding: 2px 6px; border-radius: 4px; font-size: 10px; z-index: 15; opacity: 0; transition: opacity 0.2s; }
        .copy-success.show { opacity: 1; }
        
        /* Á≤æÁÆÄÁöÑMarkdownÊ†∑Âºè */
        .node-content { font-size: 14px; line-height: 1.5; word-wrap: break-word; }
        .node-content h1, .node-content h2, .node-content h3, .node-content h4, .node-content h5, .node-content h6 { margin-top: 0.5em; margin-bottom: 0.3em; font-weight: 600; line-height: 1.25; }
        .node-content h1 { font-size: 1.5rem !important; }
        .node-content h2 { font-size: 1.3rem !important; }
        .node-content h3 { font-size: 1.2rem !important; }
        .node-content h4 { font-size: 1.1rem !important; }
        .node-content h5 { font-size: 1.05rem !important; }
        .node-content h6 { font-size: 1rem !important; color: #6c757d !important; }
        .node-content p { margin-bottom: 0.5em; }
        .node-content ul, .node-content ol { padding-left: 1.5em; margin-bottom: 0.5em; }
        .node-content li { margin-bottom: 0.2em; }
        .node-content code { background-color: #f1f3f4; border-radius: 3px; padding: 0.1em 0.3em; font-size: 0.9em; font-family: 'Courier New', monospace; }
        .node-content pre { background-color: var(--bg-color); border: 1px solid var(--border-color); border-radius: 4px; padding: 0.8em; overflow: auto; margin-bottom: 0.8em; }
        .node-content pre code { background: none; padding: 0; }
        .node-content blockquote { border-left: 4px solid var(--border-color); padding-left: 1em; margin-left: 0; color: #6c757d; margin-bottom: 0.8em; }
        .node-content table { border-collapse: collapse; width: 100%; margin-bottom: 0.8em; }
        .node-content table th, .node-content table td { border: 1px solid var(--border-color); padding: 0.3em 0.5em; text-align: left; }
        .node-content table th { background-color: var(--bg-color); font-weight: 600; }
        
        /* ÁßªÂä®Á´Ø‰ºòÂåñ */
        .mobile-sidebar-toggle {
            display: none;
            position: absolute;
            top: -3px;
            left: -3px;
            z-index: 1000;
            background: rgba(52, 58, 64, 0.9);
            border: none;
            color: white;
            border-radius: 4px;
            padding: 8px 12px;
            font-size: 14px;
        }
        
        .sidebar-backdrop {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.5);
            z-index: 999;
        }
        
        @media (max-width: 768px) {
            .mobile-sidebar-toggle {
                display: block;
            }
            
            .sidebar {
                position: fixed;
                top: 0;
                left: -100%;
                width: 85%;
                max-width: 300px;
                z-index: 1000;
                transition: left 0.3s ease;
            }
            
            .sidebar.active {
                left: 0;
            }
            
            .editor-container {
                width: 100%;
            }
            
            .node {
                width: 90%;
                max-width: 400px;
            }
            
            .toolbar {
                left: 60px;
            }
            
            .chat-input-container {
                padding: 15px;
            }
            
            .zoom-controls {
                right: 10px;
            }
        }
        
        @media (max-width: 576px) {
            .node {
                width: 95%;
                max-width: 350px;
            }
            
            .toolbar {
                left: 50px;
            }
            
            .zoom-controls {
                right: 5px;
            }
            
            .chat-input-container {
                padding: 10px;
            }
        }
    </style>
</head>
<body>
    <!-- ÁßªÂä®Á´Ø‰æßËæπÊ†èÂàáÊç¢ÊåâÈíÆ -->
    <button class="mobile-sidebar-toggle" id="mobileSidebarToggle">‚ò∞</button>
    <div class="sidebar-backdrop" id="sidebarBackdrop"></div>
    
    <div class="container-fluid">
        <div class="row">
            <div class="col-md-3 sidebar" id="sidebar">
                <div class="p-3">
                    <h3 class="mb-3 vibe-font">VibeChat<sup>(a)</sup></h3>
                    <div class="d-flex mb-2">
                        <button class="btn btn-outline-light btn-sm m-1 flex-fill" id="exportBtn" data-i18n="exportBtn">ÂØºÂá∫</button>
                        <button class="btn btn-outline-light btn-sm m-1 flex-fill" id="importBtn" data-i18n="importBtn">ÂØºÂÖ•</button>
                    </div>
                    <input type="file" id="importFile" style="display: none;" accept=".json">
                    
                    <div class="api-settings">
                        <div class="accordion" id="apiSettingsAccordion">
                            <div class="accordion-item border-0">
                                <h2 class="accordion-header" id="apiSettingsHeading">
                                    <button class="accordion-button bg-transparent p-2 ps-3 collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#apiSettingsCollapse" aria-expanded="false" aria-controls="apiSettingsCollapse">
                                        <h6 class="mb-0 small" data-i18n="apiSettings">APIËÆæÁΩÆ</h6>
                                    </button>
                                </h2>
                                <div id="apiSettingsCollapse" class="accordion-collapse collapse" aria-labelledby="apiSettingsHeading" data-bs-parent="#apiSettingsAccordion">
                                    <div class="accordion-body p-3">
                                        <div class="form-group">
                                            <label for="apiUrl" class="form-label small" data-i18n="apiUrl">APIÂú∞ÂùÄ</label>
                                            <input type="text" class="form-control form-control-sm" id="apiUrl" value="https://api.deepseek.com/chat/completions" autocomplete="off">
                                        </div>
                                        <div class="form-group mt-2">
                                            <label for="apiKey" class="form-label small" data-i18n="apiKey">APIÂØÜÈí•</label>
                                            <input type="password" class="form-control form-control-sm" id="apiKey" placeholder="ËæìÂÖ•APIÂØÜÈí•" data-i18n-placeholder="apiKeyPlaceholder" autocomplete="off">
                                        </div>
                                        <div class="form-group mt-2">
                                            <label for="modelName" class="form-label small" data-i18n="modelName">Ê®°ÂûãÂêçÁß∞</label>
                                            <input type="text" class="form-control form-control-sm" id="modelName" value="deepseek-chat" placeholder="ËæìÂÖ•Ê®°ÂûãÂêçÁß∞" data-i18n-placeholder="modelNamePlaceholder" autocomplete="off">
                                        </div>
                                        <div class="form-group mt-2">
                                            <label for="temperature" class="form-label small" data-i18n="temperature">Ê∏©Â∫¶<small> (0.1-2.0)</small></label>
                                            <input type="number" class="form-control form-control-sm" id="temperature" min="0" max="2" step="0.1" value="1.0" autocomplete="off">
                                        </div>
                                        <button class="btn btn-outline-dark btn-sm w-100 mt-3" id="testApiBtn" data-i18n="testConnection">ÊµãËØïËøûÊé•</button>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                    
                    <hr class="bg-light">
                    <div id="treeViewContainer">
                        <ul class="tree-view" id="treeView"></ul>
                    </div>
                </div>
            </div>
            
            <div class="col-md-9 editor-container">
                <div class="toolbar">
                    <div class="btn-group">
                        <button class="btn btn-dark btn-sm" id="themeToggle" title="Êó•‰πã‰∫ÆÈù¢">üåô</button>
                        <button class="btn btn-secondary btn-sm" id="clearConversationBtn" title="Ê∏ÖÁ©∫ÂØπËØù">üóëÔ∏è</button>
                        <button class="btn btn-danger btn-sm" id="deleteNodeBtn" data-i18n="deleteNode">Âà†Èô§ËäÇÁÇπ</button>
                    </div>
                </div>
                
                <div class="story-canvas-container" id="canvasContainer">
                    <div class="story-canvas" id="storyCanvas">
                        <svg class="connections" id="connections"></svg>
                    </div>
                </div>
                
                <div class="zoom-controls">
                    <div class="btn-group-vertical">
                        <button class="btn btn-light btn-sm" id="zoomInBtn">+</button>
                        <button class="btn btn-light btn-sm" id="zoomOutBtn">-</button>
                        <button class="btn btn-light btn-sm" id="resetZoomBtn">‚Üª</button>
                    </div>
                </div>
                
                <div class="chat-input-container">
                    <div class="input-group">
                        <input type="text" class="form-control" id="userInput" placeholder="ËæìÂÖ•ÊÇ®ÁöÑÈóÆÈ¢ò..." autocomplete="off" data-i18n-placeholder="inputPlaceholder">
                        <button class="btn btn-primary" id="sendBtn" data-i18n="sendBtn">ÂèëÈÄÅ</button>
                    </div>
                    <small class="form-text text-muted mt-2">
                        <span data-i18n="selectedNode">ÈÄâ‰∏≠ËäÇÁÇπ:</span> <span id="contextInfo">1</span>
                    </small>
                </div>
            </div>
        </div>
    </div>

    <script>
        // ÈÖçÁΩÆ marked.js
        marked.setOptions({
            breaks: true,
            gfm: true,
            headerIds: false,
            mangle: false
        });
        
        // Â∫îÁî®Â∏∏Èáè
        const CONSTANTS = {
            HORIZONTAL_SPACING: 300,
            VERTICAL_SPACING: 250,
            NODE_WIDTH: 450,
            NODE_HEIGHT: {
                user: 150,
                assistant: 250,
                system: 150
            }
        };
        
        // Â∫îÁî®Áä∂ÊÄÅ
        const state = {
            conversation: {
                title: "VibeChat",
                nodes: {},
                startNode: null
            },
            selectedNodeId: null,
            zoomLevel: 1,
            isDragging: false,
            dragStart: { x: 0, y: 0 },
            isMobile: window.innerWidth <= 768
        };
        
        // DOM ÂÖÉÁ¥†ÂºïÁî®
        const elements = {
            canvas: document.getElementById('storyCanvas'),
            connections: document.getElementById('connections'),
            treeView: document.getElementById('treeView'),
            contextInfo: document.getElementById('contextInfo'),
            userInput: document.getElementById('userInput'),
            sendBtn: document.getElementById('sendBtn'),
            deleteNodeBtn: document.getElementById('deleteNodeBtn'),
            clearConversationBtn: document.getElementById('clearConversationBtn'),
            sidebar: document.getElementById('sidebar'),
            mobileSidebarToggle: document.getElementById('mobileSidebarToggle'),
            sidebarBackdrop: document.getElementById('sidebarBackdrop'),
            themeToggle: document.getElementById('themeToggle')
        };

        // Â§öËØ≠Ë®ÄËµÑÊ∫ê
        const i18nResources = {
            'zh-CN': {
                pageTitle: 'VibeChat(Œ±) | Â§öÂàÜÊîØ LLM ÁΩëÈ°µËÅäÂ§©',
                exportBtn: 'ÂØºÂá∫',
                importBtn: 'ÂØºÂÖ•',
                apiSettings: 'APIËÆæÁΩÆ',
                apiUrl: 'APIÂú∞ÂùÄ',
                apiKey: 'APIÂØÜÈí•',
                apiKeyPlaceholder: 'ËæìÂÖ•APIÂØÜÈí•',
                modelName: 'Ê®°ÂûãÂêçÁß∞',
                modelNamePlaceholder: 'ËæìÂÖ•Ê®°ÂûãÂêçÁß∞',
                temperature: 'Ê∏©Â∫¶',
                testConnection: 'ÊµãËØïËøûÊé•',
                deleteNode: 'Âà†Èô§ËäÇÁÇπ',
                inputPlaceholder: 'ËæìÂÖ•ÊÇ®ÁöÑÈóÆÈ¢ò...',
                sendBtn: 'ÂèëÈÄÅ',
                selectedNode: 'ÈÄâ‰∏≠ËäÇÁÇπ:',
                confirmDelete: 'Á°ÆÂÆöË¶ÅÂà†Èô§Ëøô‰∏™ËäÇÁÇπÂèäÂÖ∂ÊâÄÊúâÂ≠êËäÇÁÇπÂêóÔºü',
                confirmClear: 'Á°ÆÂÆöË¶ÅÊ∏ÖÁ©∫ÂØπËØùÂêóÔºüËøôÂ∞ÜÂà†Èô§ÊâÄÊúâËäÇÁÇπÔºåÂè™‰øùÁïôÁ≥ªÁªüÊèêÁ§∫Ê∂àÊÅØ„ÄÇ',
                confirmClearAgain: 'ÂÜçÊ¨°Á°ÆËÆ§ÔºöËøôÂ∞ÜÊ∞∏‰πÖÂà†Èô§ÊâÄÊúâÂØπËØùÂÜÖÂÆπÔºåÂè™‰øùÁïôÁ≥ªÁªüËäÇÁÇπ„ÄÇ',
                clearedAlert: 'ÂØπËØùÂ∑≤Ê∏ÖÁ©∫ÔºåÂè™‰øùÁïôÁ≥ªÁªüÊèêÁ§∫Ê∂àÊÅØ„ÄÇ',
                enterQuestion: 'ËØ∑ËæìÂÖ•ÈóÆÈ¢ò',
                selectNode: 'ËØ∑ÂÖàÈÄâÊã©‰∏Ä‰∏™ËäÇÁÇπ',
                setApi: 'ËØ∑ËÆæÁΩÆAPIÂú∞ÂùÄÂíåAPIÂØÜÈí•',
                resendUserOnly: 'Âè™ËÉΩÂú®Áî®Êà∑ËäÇÁÇπ‰∏äÈáçÂèë',
                apiSuccess: 'APIËøûÊé•ÊàêÂäüÔºÅ',
                apiUnexpected: 'APIËøûÊé•ÊµãËØïÂÆåÊàêÔºå‰ΩÜÂìçÂ∫î‰∏çÁ¨¶ÂêàÈ¢ÑÊúü„ÄÇ',
                importSuccess: 'ÂØπËØùÂØºÂÖ•ÊàêÂäüÔºÅ',
                invalidFormat: 'Êó†ÊïàÁöÑÂØπËØùÊñá‰ª∂Ê†ºÂºè',
                importFailed: 'ÂØºÂÖ•Â§±Ë¥•Ôºö',
                system: 'System',
                user: 'User',
                assistant: 'Assistant',
                assistantReply: 'Âä©ÊâãÂõûÂ§ç',
                reasoningProcess: '‚áÖ Êé®ÁêÜËøáÁ®ã',
                resendTooltip: 'ÈáçÂèëÊ≠§Ê∂àÊÅØ',
                copyTooltip: 'Â§çÂà∂ÂÜÖÂÆπ',
                copySuccess: 'Â§çÂà∂ÊàêÂäü',
                darkThemeTooltip: 'Êúà‰πãÊöóÈù¢',
                lightThemeTooltip: 'Êó•‰πã‰∫ÆÈù¢',
                clearConversationTitle: 'Ê∏ÖÁ©∫ÂØπËØù',
                systemPrompt: '‰Ω†ÊòØ‰∏Ä‰∏™ÊúâÁî®ÁöÑAIÂä©Êâã„ÄÇ',
                testMessage: 'ËØ∑ÂõûÂ§ç"ËøûÊé•ÊàêÂäü"‰ª•Á°ÆËÆ§APIËøûÊé•Ê≠£Â∏∏„ÄÇ',
                cannotDeleteStart: '‰∏çËÉΩÂà†Èô§Ëµ∑ÂßãËäÇÁÇπ',
                sending: 'ÂèëÈÄÅ‰∏≠...',
                testing: 'ÊµãËØï‰∏≠...',
                editFinalAnswer: 'ÁºñËæëËäÇÁÇπÊúÄÁªàÂõûÁ≠î:',
                editNodeContent: 'ÁºñËæëËäÇÁÇπÂÜÖÂÆπ:'
            },
            'zh-TW': {
                pageTitle: 'VibeChat(Œ±) | Â§öÂàÜÊîØ LLM Á∂≤È†ÅËÅäÂ§©',
                exportBtn: 'Â∞éÂá∫',
                importBtn: 'Â∞éÂÖ•',
                apiSettings: 'APIË®≠ÁΩÆ',
                apiUrl: 'APIÂú∞ÂùÄ',
                apiKey: 'APIÂØÜÈë∞',
                apiKeyPlaceholder: 'Ëº∏ÂÖ•APIÂØÜÈë∞',
                modelName: 'Ê®°ÂûãÂêçÁ®±',
                modelNamePlaceholder: 'Ëº∏ÂÖ•Ê®°ÂûãÂêçÁ®±',
                temperature: 'Ê∫´Â∫¶',
                testConnection: 'Ê∏¨Ë©¶ÈÄ£Êé•',
                deleteNode: 'Âà™Èô§ÁØÄÈªû',
                inputPlaceholder: 'Ëº∏ÂÖ•ÊÇ®ÁöÑÂïèÈ°å...',
                sendBtn: 'ÁôºÈÄÅ',
                selectedNode: 'ÈÅ∏‰∏≠ÁØÄÈªû:',
                confirmDelete: 'Á¢∫ÂÆöË¶ÅÂà™Èô§ÈÄôÂÄãÁØÄÈªûÂèäÂÖ∂ÊâÄÊúâÂ≠êÁØÄÈªûÂóéÔºü',
                confirmClear: 'Á¢∫ÂÆöË¶ÅÊ∏ÖÁ©∫Â∞çË©±ÂóéÔºüÈÄôÂ∞áÂà™Èô§ÊâÄÊúâÁØÄÈªûÔºåÂè™‰øùÁïôÁ≥ªÁµ±ÊèêÁ§∫Ê∂àÊÅØ„ÄÇ',
                confirmClearAgain: 'ÂÜçÊ¨°Á¢∫Ë™çÔºöÈÄôÂ∞áÊ∞∏‰πÖÂà™Èô§ÊâÄÊúâÂ∞çË©±ÂÖßÂÆπÔºåÂè™‰øùÁïôÁ≥ªÁµ±ÁØÄÈªû„ÄÇ',
                clearedAlert: 'Â∞çË©±Â∑≤Ê∏ÖÁ©∫ÔºåÂè™‰øùÁïôÁ≥ªÁµ±ÊèêÁ§∫Ê∂àÊÅØ„ÄÇ',
                enterQuestion: 'Ë´ãËº∏ÂÖ•ÂïèÈ°å',
                selectNode: 'Ë´ãÂÖàÈÅ∏Êìá‰∏ÄÂÄãÁØÄÈªû',
                setApi: 'Ë´ãË®≠ÁΩÆAPIÂú∞ÂùÄÂíåAPIÂØÜÈë∞',
                resendUserOnly: 'Âè™ËÉΩÂú®Áî®Êà∂ÁØÄÈªû‰∏äÈáçÁôº',
                apiSuccess: 'APIÈÄ£Êé•ÊàêÂäüÔºÅ',
                apiUnexpected: 'APIÈÄ£Êé•Ê∏¨Ë©¶ÂÆåÊàêÔºå‰ΩÜÈüøÊáâ‰∏çÁ¨¶ÂêàÈ†êÊúü„ÄÇ',
                importSuccess: 'Â∞çË©±Â∞éÂÖ•ÊàêÂäüÔºÅ',
                invalidFormat: 'ÁÑ°ÊïàÁöÑÂ∞çË©±Êñá‰ª∂Ê†ºÂºè',
                importFailed: 'Â∞éÂÖ•Â§±ÊïóÔºö',
                system: 'System',
                user: 'User',
                assistant: 'Assistant',
                assistantReply: 'Âä©ÊâãÂõûË¶Ü',
                reasoningProcess: '‚áÖ Êé®ÁêÜÈÅéÁ®ã',
                resendTooltip: 'ÈáçÁôºÊ≠§Ê∂àÊÅØ',
                copyTooltip: 'Ë§áË£ΩÂÖßÂÆπ',
                copySuccess: 'Ë§áË£ΩÊàêÂäü',
                darkThemeTooltip: 'Êúà‰πãÊöóÈù¢',
                lightThemeTooltip: 'Êó•‰πã‰∫ÆÈù¢',
                clearConversationTitle: 'Ê∏ÖÁ©∫Â∞çË©±',
                systemPrompt: '‰Ω†ÊòØ‰∏ÄÂÄãÊúâÁî®ÁöÑAIÂä©Êâã„ÄÇ',
                testMessage: 'Ë´ãÂõûÂæ©"ÈÄ£Êé•ÊàêÂäü"‰ª•Á¢∫Ë™çAPIÈÄ£Êé•Ê≠£Â∏∏„ÄÇ',
                cannotDeleteStart: '‰∏çËÉΩÂà™Èô§Ëµ∑ÂßãÁØÄÈªû',
                sending: 'ÁôºÈÄÅ‰∏≠...',
                testing: 'Ê∏¨Ë©¶‰∏≠...',
                editFinalAnswer: 'Á∑®ËºØÁØÄÈªûÊúÄÁµÇÂõûÁ≠î:',
                editNodeContent: 'Á∑®ËºØÁØÄÈªûÂÖßÂÆπ:'
            },
            'en': {
                pageTitle: 'VibeChat(Œ±) | Multi-branch LLM WebChat',
                exportBtn: 'Export',
                importBtn: 'Import',
                apiSettings: 'API Settings',
                apiUrl: 'API URL',
                apiKey: 'API Key',
                apiKeyPlaceholder: 'Enter API Key',
                modelName: 'Model Name',
                modelNamePlaceholder: 'Enter Model Name',
                temperature: 'Temperature',
                testConnection: 'Test Connection',
                deleteNode: 'Delete Node',
                inputPlaceholder: 'Enter your question...',
                sendBtn: 'Send',
                selectedNode: 'Selected Node:',
                confirmDelete: 'Are you sure you want to delete this node and all its children?',
                confirmClear: 'Are you sure you want to clear the conversation? This will delete all nodes except the system prompt.',
                confirmClearAgain: 'Confirm again: This will permanently delete all conversation content, keeping only the system node.',
                clearedAlert: 'Conversation cleared, only system prompt remains.',
                enterQuestion: 'Please enter a question',
                selectNode: 'Please select a node first',
                setApi: 'Please set API URL and API Key',
                resendUserOnly: 'Can only resend on user nodes',
                apiSuccess: 'API connection successful!',
                apiUnexpected: 'API connection test completed, but response was unexpected.',
                importSuccess: 'Conversation imported successfully!',
                invalidFormat: 'Invalid conversation file format',
                importFailed: 'Import failed:',
                system: 'System',
                user: 'User',
                assistant: 'Assistant',
                assistantReply: 'Assistant Reply',
                reasoningProcess: '‚áÖ Reasoning Process',
                resendTooltip: 'Resend this message',
                copyTooltip: 'Copy content',
                copySuccess: 'Copied successfully',
                darkThemeTooltip: 'MoonShot',
                lightThemeTooltip: 'SunFlare',
                clearConversationTitle: 'Clear Conversation',
                systemPrompt: 'You are a helpful AI assistant.',
                testMessage: 'Please reply "Connection successful" to confirm API connection is normal.',
                cannotDeleteStart: 'Cannot delete start node',
                sending: 'Sending...',
                testing: 'Testing...',
                editFinalAnswer: 'Edit node final answer:',
                editNodeContent: 'Edit node content:'
            },
            'ja': {
                pageTitle: 'VibeChat(Œ±) | „Éû„É´„ÉÅ„Éñ„É©„É≥„ÉÅ LLM „Ç¶„Çß„Éñ„ÉÅ„É£„ÉÉ„Éà',
                exportBtn: '„Ç®„ÇØ„Çπ„Éù„Éº„Éà',
                importBtn: '„Ç§„É≥„Éù„Éº„Éà',
                apiSettings: 'APIË®≠ÂÆö',
                apiUrl: 'API URL',
                apiKey: 'API„Ç≠„Éº',
                apiKeyPlaceholder: 'API„Ç≠„Éº„ÇíÂÖ•Âäõ',
                modelName: '„É¢„Éá„É´Âêç',
                modelNamePlaceholder: '„É¢„Éá„É´Âêç„ÇíÂÖ•Âäõ',
                temperature: 'Ê∏©Â∫¶',
                testConnection: 'Êé•Á∂ö„ÉÜ„Çπ„Éà',
                deleteNode: '„Éé„Éº„ÉâÂâäÈô§',
                inputPlaceholder: 'Ë≥™Âïè„ÇíÂÖ•Âäõ„Åó„Å¶„Åè„Å†„Åï„ÅÑ...',
                sendBtn: 'ÈÄÅ‰ø°',
                selectedNode: 'ÈÅ∏Êäû„Éé„Éº„Éâ:',
                confirmDelete: '„Åì„ÅÆ„Éé„Éº„Éâ„Å®„Åô„Åπ„Å¶„ÅÆÂ≠ê„Éé„Éº„Éâ„ÇíÂâäÈô§„Åó„Å¶„ÇÇ„Çà„Çç„Åó„ÅÑ„Åß„Åô„ÅãÔºü',
                confirmClear: '‰ºöË©±„Çí„ÇØ„É™„Ç¢„Åó„Å¶„ÇÇ„Çà„Çç„Åó„ÅÑ„Åß„Åô„ÅãÔºü„Ç∑„Çπ„ÉÜ„É†„Éó„É≠„É≥„Éó„Éà„ÇíÈô§„Åè„Åô„Åπ„Å¶„ÅÆ„Éé„Éº„Éâ„ÅåÂâäÈô§„Åï„Çå„Åæ„Åô„ÄÇ',
                confirmClearAgain: '„ÇÇ„ÅÜ‰∏ÄÂ∫¶Á¢∫Ë™çÔºö„Åô„Åπ„Å¶„ÅÆ‰ºöË©±ÂÜÖÂÆπ„ÅåÂÆåÂÖ®„Å´ÂâäÈô§„Åï„Çå„ÄÅ„Ç∑„Çπ„ÉÜ„É†„Éé„Éº„Éâ„ÅÆ„Åø„ÅåÊÆã„Çä„Åæ„Åô„ÄÇ',
                clearedAlert: '‰ºöË©±„Åå„ÇØ„É™„Ç¢„Åï„Çå„ÄÅ„Ç∑„Çπ„ÉÜ„É†„Éó„É≠„É≥„Éó„Éà„ÅÆ„Åø„ÅåÊÆã„Çä„Åæ„Åó„Åü„ÄÇ',
                enterQuestion: 'Ë≥™Âïè„ÇíÂÖ•Âäõ„Åó„Å¶„Åè„Å†„Åï„ÅÑ',
                selectNode: '„Åæ„Åö„Éé„Éº„Éâ„ÇíÈÅ∏Êäû„Åó„Å¶„Åè„Å†„Åï„ÅÑ',
                setApi: 'API URL„Å®API„Ç≠„Éº„ÇíË®≠ÂÆö„Åó„Å¶„Åè„Å†„Åï„ÅÑ',
                resendUserOnly: '„É¶„Éº„Ç∂„Éº„Éé„Éº„Éâ„Åß„ÅÆ„ÅøÂÜçÈÄÅ‰ø°„Åß„Åç„Åæ„Åô',
                apiSuccess: 'APIÊé•Á∂ö„Å´ÊàêÂäü„Åó„Åæ„Åó„ÅüÔºÅ',
                apiUnexpected: 'APIÊé•Á∂ö„ÉÜ„Çπ„Éà„ÅØÂÆå‰∫Ü„Åó„Åæ„Åó„Åü„Åå„ÄÅÂøúÁ≠î„Åå‰∫àÊúü„Åõ„Å¨„ÇÇ„ÅÆ„Åß„Åó„Åü„ÄÇ',
                importSuccess: '‰ºöË©±„ÅÆ„Ç§„É≥„Éù„Éº„Éà„Å´ÊàêÂäü„Åó„Åæ„Åó„ÅüÔºÅ',
                invalidFormat: 'ÁÑ°Âäπ„Å™‰ºöË©±„Éï„Ç°„Ç§„É´ÂΩ¢Âºè',
                importFailed: '„Ç§„É≥„Éù„Éº„Éà„Å´Â§±Êïó„Åó„Åæ„Åó„ÅüÔºö',
                system: 'System',
                user: 'User',
                assistant: 'Assistant',
                assistantReply: '„Ç¢„Ç∑„Çπ„Çø„É≥„ÉàËøî‰ø°',
                reasoningProcess: '‚áÖ Êé®Ë´ñ„Éó„É≠„Çª„Çπ',
                resendTooltip: '„Åì„ÅÆ„É°„ÉÉ„Çª„Éº„Ç∏„ÇíÂÜçÈÄÅ‰ø°',
                copyTooltip: 'ÂÜÖÂÆπ„Çí„Ç≥„Éî„Éº',
                copySuccess: '„Ç≥„Éî„ÉºÊàêÂäü',
                darkThemeTooltip: 'MoonShot',
                lightThemeTooltip: 'SunFlare',
                clearConversationTitle: '‰ºöË©±„Çí„ÇØ„É™„Ç¢',
                systemPrompt: '„ÅÇ„Å™„Åü„ÅØÂΩπÁ´ã„Å§AI„Ç¢„Ç∑„Çπ„Çø„É≥„Éà„Åß„Åô„ÄÇ',
                testMessage: 'APIÊé•Á∂ö„ÅåÊ≠£Â∏∏„Åß„ÅÇ„Çã„Åì„Å®„ÇíÁ¢∫Ë™ç„Åô„Çã„Åü„ÇÅ„Å´„ÄåÊé•Á∂öÊàêÂäü„Äç„Å®Ëøî‰ø°„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ',
                cannotDeleteStart: 'ÈñãÂßã„Éé„Éº„Éâ„ÇíÂâäÈô§„Åß„Åç„Åæ„Åõ„Çì',
                sending: 'ÈÄÅ‰ø°‰∏≠...',
                testing: '„ÉÜ„Çπ„Éà‰∏≠...',
                editFinalAnswer: '„Éé„Éº„Éâ„ÅÆÊúÄÁµÇÂõûÁ≠î„ÇíÁ∑®ÈõÜ:',
                editNodeContent: '„Éé„Éº„Éâ„ÅÆÂÜÖÂÆπ„ÇíÁ∑®ÈõÜ:'
            }
        };

        // ÂΩìÂâçËØ≠Ë®Ä
        let currentLanguage = 'zh-CN';

        // ÂàùÂßãÂåñÂ∫îÁî®
        document.addEventListener('DOMContentLoaded', function() {
            // ÂàùÂßãÂåñËØ≠Ë®Ä
            initLanguage();
            
            // ÂàùÂßãÂåñ‰∏ªÈ¢ò
            initTheme();
            
            loadStateFromLocalStorage();
            
            if (!state.conversation.startNode || Object.keys(state.conversation.nodes).length === 0) {
                const initialX = (5000 - CONSTANTS.NODE_WIDTH) / 2;
                createNode("system", i18n('systemPrompt'), initialX, 200, true);
            }
            
            setupEventListeners();
            setupMobileEvents();
            renderAll();
            
            const container = document.getElementById('canvasContainer');
            if (state.selectedNodeId) {
                scrollToNode(state.selectedNodeId);
            } else {
                container.scrollTo(2500 - container.clientWidth / 2, 0);
            }
            
            window.addEventListener('beforeunload', saveStateToLocalStorage);
            window.addEventListener('resize', handleResize);
        });
        
        // ÂàùÂßãÂåñËØ≠Ë®Ä
        function initLanguage() {
            const browserLang = navigator.language || navigator.userLanguage;
            const lang = browserLang.split('-')[0];
            
            if (lang === 'zh') {
                currentLanguage = browserLang.includes('TW') || browserLang.includes('HK') ? 'zh-TW' : 'zh-CN';
            } else if (lang === 'ja') {
                currentLanguage = 'ja';
            } else {
                currentLanguage = 'en';
            }
            
            document.title = i18n('pageTitle');
            applyLanguage();
        }
        
        // Â∫îÁî®ËØ≠Ë®Ä
        function applyLanguage() {
            document.querySelectorAll('[data-i18n]').forEach(element => {
                const key = element.getAttribute('data-i18n');
                if (i18nResources[currentLanguage][key]) {
                    element.textContent = i18nResources[currentLanguage][key];
                }
            });
            
            document.querySelectorAll('[data-i18n-placeholder]').forEach(element => {
                const key = element.getAttribute('data-i18n-placeholder');
                if (i18nResources[currentLanguage][key]) {
                    element.placeholder = i18nResources[currentLanguage][key];
                }
            });
            
            // Êõ¥Êñ∞ÊåâÈíÆÁöÑtitleÂ±ûÊÄß
            document.querySelectorAll('.resend-btn').forEach(btn => {
                btn.title = i18n('resendTooltip');
            });
            
            document.querySelectorAll('.copy-btn').forEach(btn => {
                btn.title = i18n('copyTooltip');
            });
            
            // Êõ¥Êñ∞Ê∏ÖÁ©∫ÂØπËØùÊåâÈíÆÁöÑtitle
            elements.clearConversationBtn.title = i18n('clearConversationTitle');
            
            updateThemeTooltip();
        }
        
        // ÁøªËØëÂáΩÊï∞
        function i18n(key) {
            return i18nResources[currentLanguage][key] || key;
        }
        
        // ÂàùÂßãÂåñ‰∏ªÈ¢ò
        function initTheme() {
            // Ê£ÄÊµãÁ≥ªÁªüÂÅèÂ•Ω
            const prefersDark = window.matchMedia('(prefers-color-scheme: dark)').matches;
            const savedTheme = localStorage.getItem('vibechat-theme') || (prefersDark ? 'dark' : 'light');
            document.documentElement.setAttribute('data-theme', savedTheme);
            updateThemeToggle(savedTheme);
        }
        
        // Êõ¥Êñ∞‰∏ªÈ¢òÂàáÊç¢ÊåâÈíÆ
        function updateThemeToggle(theme) {
            elements.themeToggle.textContent = theme === 'dark' ? '‚òÄÔ∏è' : 'üåô';
            updateThemeTooltip();
        }
        
        // Êõ¥Êñ∞‰∏ªÈ¢òÊèêÁ§∫
        function updateThemeTooltip() {
            const currentTheme = document.documentElement.getAttribute('data-theme');
            elements.themeToggle.title = currentTheme === 'dark' ? i18n('lightThemeTooltip') : i18n('darkThemeTooltip');
        }
        
        // ÂàáÊç¢‰∏ªÈ¢ò
        function toggleTheme() {
            const currentTheme = document.documentElement.getAttribute('data-theme');
            const newTheme = currentTheme === 'dark' ? 'light' : 'dark';
            
            document.documentElement.setAttribute('data-theme', newTheme);
            localStorage.setItem('vibechat-theme', newTheme);
            updateThemeToggle(newTheme);
        }
        
        // ÁßªÂä®Á´Ø‰∫ã‰ª∂ËÆæÁΩÆ
        function setupMobileEvents() {
            if (!state.isMobile) return;
            
            elements.mobileSidebarToggle.addEventListener('click', toggleSidebar);
            elements.sidebarBackdrop.addEventListener('click', closeSidebar);
            
            // ÁÇπÂáªÊ†ëËäÇÁÇπÊó∂Ëá™Âä®ÂÖ≥Èó≠‰æßËæπÊ†è
            elements.treeView.addEventListener('click', function(e) {
                if (e.target.closest('.tree-node')) {
                    setTimeout(closeSidebar, 300);
                }
            });
        }
        
        function toggleSidebar() {
            elements.sidebar.classList.toggle('active');
            elements.sidebarBackdrop.style.display = elements.sidebar.classList.contains('active') ? 'block' : 'none';
        }
        
        function closeSidebar() {
            elements.sidebar.classList.remove('active');
            elements.sidebarBackdrop.style.display = 'none';
        }
        
        function handleResize() {
            state.isMobile = window.innerWidth <= 768;
            
            if (!state.isMobile) {
                closeSidebar();
            }
        }
        
        // ‰∫ã‰ª∂ÁõëÂê¨Âô®ËÆæÁΩÆ
        function setupEventListeners() {
            elements.deleteNodeBtn.addEventListener('click', deleteNode);
            elements.clearConversationBtn.addEventListener('click', clearConversation);
            document.getElementById('exportBtn').addEventListener('click', exportConversation);
            document.getElementById('importBtn').addEventListener('click', () => document.getElementById('importFile').click());
            document.getElementById('importFile').addEventListener('change', importConversation);
            document.getElementById('zoomInBtn').addEventListener('click', () => adjustZoom(0.1));
            document.getElementById('zoomOutBtn').addEventListener('click', () => adjustZoom(-0.1));
            document.getElementById('resetZoomBtn').addEventListener('click', resetZoom);
            elements.sendBtn.addEventListener('click', sendMessage);
            elements.userInput.addEventListener('keypress', e => e.key === 'Enter' && sendMessage());
            document.getElementById('testApiBtn').addEventListener('click', testApiConnection);
            elements.themeToggle.addEventListener('click', toggleTheme);
            
            // ËäÇÁÇπ‰∫ã‰ª∂ÂßîÊâò
            elements.canvas.addEventListener('click', handleNodeClick);
        }
        
        // ËäÇÁÇπÁÇπÂáª‰∫ã‰ª∂Â§ÑÁêÜ
        function handleNodeClick(e) {
            const nodeElement = e.target.closest('.node');
            if (!nodeElement) return;
            
            const nodeId = nodeElement.id;
            
            if (e.target.classList.contains('reasoning-toggle')) {
                toggleReasoning(nodeId);
                return;
            }
            
            if (e.target.classList.contains('resend-btn')) {
                resendMessage(nodeId);
                return;
            }
            
            if (e.target.classList.contains('copy-btn')) {
                copyNodeContent(nodeId);
                return;
            }
            
            if (e.target.classList.contains('node-content') || 
                e.target.classList.contains('reasoning-content') ||
                e.target.classList.contains('final-answer')) {
                editNodeContent(nodeId);
            } else {
                selectNode(nodeId);
            }
        }
        
        // ËäÇÁÇπÁÆ°ÁêÜÂáΩÊï∞
        function createNode(role, content, x, y, isStart = false, reasoning = null) {
            const id = 'node_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);
            
            state.conversation.nodes[id] = {
                id,
                role,
                content,
                reasoning,
                branches: [],
                position: { x, y }
            };
            
            if (isStart) {
                state.conversation.startNode = id;
                state.selectedNodeId = id;
            }
            
            return id;
        }
        
        function deleteNode() {
            if (!state.selectedNodeId || state.selectedNodeId === state.conversation.startNode) {
                alert(i18n('cannotDeleteStart'));
                return;
            }
            
            if (!confirm(i18n('confirmDelete'))) return;
            
            deleteNodeAndChildren(state.selectedNodeId);
            state.selectedNodeId = null;
            renderAll();
            saveStateToLocalStorage();
        }
        
        function deleteNodeAndChildren(nodeId) {
            if (!state.conversation.nodes[nodeId]) return;
            
            state.conversation.nodes[nodeId].branches.forEach(branch => {
                deleteNodeAndChildren(branch.nextNodeId);
            });
            
            Object.values(state.conversation.nodes).forEach(node => {
                node.branches = node.branches.filter(branch => branch.nextNodeId !== nodeId);
            });
            
            delete state.conversation.nodes[nodeId];
        }
        
        function clearConversation() {
            if (!confirm(i18n('confirmClear'))) return;
            if (!confirm(i18n('confirmClearAgain'))) return;
            
            const systemNode = state.conversation.nodes[state.conversation.startNode];
            if (!systemNode) return;
            
            state.conversation.nodes = {};
            state.conversation.nodes[state.conversation.startNode] = systemNode;
            systemNode.branches = [];
            state.selectedNodeId = state.conversation.startNode;
            
            renderAll();
            saveStateToLocalStorage();
            
            alert(i18n('clearedAlert'));
        }
        
        // Ê∂àÊÅØÂèëÈÄÅÂíåAPIË∞ÉÁî®
        async function sendMessage() {
            const userInput = elements.userInput.value.trim();
            if (!userInput) {
                alert(i18n('enterQuestion'));
                return;
            }
            
            if (!state.selectedNodeId) {
                alert(i18n('selectNode'));
                return;
            }
            
            const apiUrl = document.getElementById('apiUrl').value.trim();
            const apiKey = document.getElementById('apiKey').value.trim();
            const modelName = document.getElementById('modelName').value.trim() || "deepseek-chat";
            const temperature = parseFloat(document.getElementById('temperature').value) || 1.0;
            
            if (!apiUrl || !apiKey) {
                alert(i18n('setApi'));
                return;
            }
            
            elements.sendBtn.disabled = true;
            elements.userInput.disabled = true;
            elements.sendBtn.textContent = i18n('sending');
            
            try {
                const contextMessages = getContextMessages(state.selectedNodeId);
                contextMessages.push({ role: 'user', content: userInput });
                
                const parentNode = state.conversation.nodes[state.selectedNodeId];
                const userNodePos = calculateNodePosition(parentNode, 'user');
                const newUserNodeId = createNode("user", userInput, userNodePos.x, userNodePos.y);
                
                const assistantNodePos = calculateNodePosition(state.conversation.nodes[newUserNodeId], 'assistant');
                const newAssistantNodeId = createNode("assistant", "", assistantNodePos.x, assistantNodePos.y);
                
                parentNode.branches.push({
                    id: 'branch_' + Date.now(),
                    text: userInput.substring(0, 30) + (userInput.length > 30 ? '...' : ''),
                    nextNodeId: newUserNodeId
                });
                
                state.conversation.nodes[newUserNodeId].branches.push({
                    id: 'branch_' + Date.now(),
                    text: i18n('assistantReply'),
                    nextNodeId: newAssistantNodeId
                });
                
                state.selectedNodeId = newAssistantNodeId;
                elements.userInput.value = '';
                
                renderAll();
                scrollToNode(newAssistantNodeId);
                
                await callDeepseekAPIStream(apiUrl, apiKey, modelName, temperature, contextMessages, newAssistantNodeId);
                
            } catch (error) {
                console.error('Failed to send message:', error);
                alert(i18n('sendFailed') + error.message);
            } finally {
                elements.sendBtn.disabled = false;
                elements.userInput.disabled = false;
                elements.sendBtn.textContent = i18n('sendBtn');
                saveStateToLocalStorage();
            }
        }
        
        async function resendMessage(userNodeId) {
            const userNode = state.conversation.nodes[userNodeId];
            if (!userNode || userNode.role !== 'user') {
                alert(i18n('resendUserOnly'));
                return;
            }
            
            const apiUrl = document.getElementById('apiUrl').value.trim();
            const apiKey = document.getElementById('apiKey').value.trim();
            const modelName = document.getElementById('modelName').value.trim() || "deepseek-chat";
            const temperature = parseFloat(document.getElementById('temperature').value) || 1.0;
            
            if (!apiUrl || !apiKey) {
                alert(i18n('setApi'));
                return;
            }
            
            const assistantNodePos = calculateNodePosition(userNode, 'assistant');
            const newAssistantNodeId = createNode("assistant", "", assistantNodePos.x, assistantNodePos.y);
            
            userNode.branches.push({
                id: 'branch_' + Date.now(),
                text: i18n('assistantReply'),
                nextNodeId: newAssistantNodeId
            });
            
            state.selectedNodeId = newAssistantNodeId;
            
            renderAll();
            scrollToNode(newAssistantNodeId);
            
            const contextMessages = getContextMessages(userNodeId);
            
            try {
                await callDeepseekAPIStream(apiUrl, apiKey, modelName, temperature, contextMessages, newAssistantNodeId);
                saveStateToLocalStorage();
            } catch (error) {
                console.error('Failed to resend message:', error);
                alert(i18n('resendFailed') + error.message);
            }
        }
        
        async function callDeepseekAPIStream(apiUrl, apiKey, modelName, temperature, messages, assistantNodeId) {
            const assistantNode = state.conversation.nodes[assistantNodeId];
            
            assistantNode.content = '';
            assistantNode.reasoning = null;
            
            assistantNode.content = '<span class="typing-indicator"></span><span class="typing-indicator"></span><span class="typing-indicator"></span>';
            renderNodes();
            
            try {
                const response = await fetch(apiUrl, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'Authorization': `Bearer ${apiKey}`
                    },
                    body: JSON.stringify({
                        model: modelName,
                        messages,
                        stream: true,
                        temperature: temperature
                    })
                });
                
                if (!response.ok) {
                    throw new Error(`API request failed: ${response.status} ${response.statusText}`);
                }
                
                const reader = response.body.getReader();
                const decoder = new TextDecoder();
                let assistantContent = '';
                let reasoningContent = '';
                let isReasonerModel = false;
                
                while (true) {
                    const { done, value } = await reader.read();
                    if (done) break;
                    
                    const chunk = decoder.decode(value);
                    const lines = chunk.split('\n');
                    
                    for (const line of lines) {
                        if (line.startsWith('data: ') && line !== 'data: [DONE]') {
                            try {
                                const data = JSON.parse(line.slice(6));
                                
                                if (data.choices?.[0]?.delta?.reasoning_content !== undefined) {
                                    isReasonerModel = true;
                                    reasoningContent += data.choices[0].delta.reasoning_content || '';
                                    assistantNode.reasoning = reasoningContent;
                                }
                                
                                if (data.choices?.[0]?.delta?.content) {
                                    assistantContent += data.choices[0].delta.content;
                                    assistantNode.content = assistantContent;
                                }
                                
                                renderNodes();
                            } catch (e) {
                                // Ignore parsing errors
                            }
                        }
                    }
                }
                
                if (isReasonerModel) {
                    assistantNode.reasoning = reasoningContent;
                    assistantNode.content = assistantContent;
                } else {
                    assistantNode.content = assistantContent;
                }
                
                renderAll();
                
            } catch (error) {
                console.error('Stream response error:', error);
                assistantNode.content = 'Error: ' + error.message;
                renderAll();
            }
        }
        
        async function testApiConnection() {
            const apiUrl = document.getElementById('apiUrl').value.trim();
            const apiKey = document.getElementById('apiKey').value.trim();
            const modelName = document.getElementById('modelName').value.trim() || "deepseek-chat";
            const temperature = parseFloat(document.getElementById('temperature').value) || 1.0;
            
            if (!apiUrl || !apiKey) {
                alert(i18n('setApi'));
                return;
            }
            
            const testBtn = document.getElementById('testApiBtn');
            testBtn.disabled = true;
            testBtn.textContent = i18n('testing');
            
            try {
                const response = await fetch(apiUrl, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'Authorization': `Bearer ${apiKey}`
                    },
                    body: JSON.stringify({
                        model: modelName,
                        messages: [
                            { role: 'system', content: i18n('systemPrompt') },
                            { role: 'user', content: i18n('testMessage') }
                        ],
                        stream: false,
                        temperature: temperature
                    })
                });
                
                if (!response.ok) {
                    throw new Error(`API request failed: ${response.status} ${response.statusText}`);
                }
                
                const data = await response.json();
                
                if (data.choices?.[0]?.message?.content) {
                    alert(i18n('apiSuccess'));
                } else {
                    alert(i18n('apiUnexpected'));
                }
            } catch (error) {
                alert(i18n('apiFailed') + error.message);
            } finally {
                testBtn.disabled = false;
                testBtn.textContent = i18n('testConnection');
            }
        }
        
        // Ê∏≤ÊüìÂáΩÊï∞
        function renderAll() {
            renderNodes();
            renderConnections();
            renderTreeView();
            updateUI();
            updateContextInfo();
        }
        
        function renderNodes() {
            const canvas = elements.canvas;
            const existingNodes = canvas.querySelectorAll('.node');
            const existingNodeIds = new Set(Array.from(existingNodes).map(node => node.id));
            const currentNodeIds = new Set(Object.keys(state.conversation.nodes));
            
            // Âà†Èô§‰∏çÂ≠òÂú®ÁöÑËäÇÁÇπ
            existingNodes.forEach(node => {
                if (!currentNodeIds.has(node.id)) {
                    node.remove();
                }
            });
            
            // ÂàõÂª∫ÊàñÊõ¥Êñ∞ËäÇÁÇπ
            Object.values(state.conversation.nodes).forEach(node => {
                let nodeElement = document.getElementById(node.id);
                
                if (!nodeElement) {
                    nodeElement = createNodeElement(node);
                    canvas.appendChild(nodeElement);
                    makeDraggable(nodeElement, node);
                } else {
                    updateNodeElement(nodeElement, node);
                }
            });
            
            updateSelection();
        }
        
        function createNodeElement(node) {
            const element = document.createElement('div');
            element.className = `node ${node.role}`;
            element.id = node.id;
            element.style.left = node.position.x + 'px';
            element.style.top = node.position.y + 'px';
            
            const roleIndicator = document.createElement('div');
            roleIndicator.className = `role-indicator role-${node.role}`;
            roleIndicator.textContent = i18n(node.role);
            
            // ‰∏∫Áî®Êà∑ËäÇÁÇπÊ∑ªÂä†ÈáçÂèëÊåâÈíÆ
            if (node.role === 'user') {
                const resendBtn = document.createElement('button');
                resendBtn.className = 'resend-btn mt-1';
                resendBtn.textContent = '‚Üª';
                resendBtn.title = i18n('resendTooltip');
                resendBtn.dataset.nodeId = node.id;
                element.appendChild(resendBtn);
            }
            
            // ‰∏∫ÊâÄÊúâËäÇÁÇπÊ∑ªÂä†Â§çÂà∂ÊåâÈíÆ
            const copyBtn = document.createElement('button');
            copyBtn.className = 'copy-btn mt-1';
            copyBtn.textContent = '‚éò';
            copyBtn.title = i18n('copyTooltip');
            copyBtn.dataset.nodeId = node.id;
            element.appendChild(copyBtn);
            
            const content = document.createElement('div');
            content.className = 'node-content';
            
            if (node.reasoning !== undefined && node.reasoning !== null) {
                const reasoningToggle = document.createElement('div');
                reasoningToggle.className = 'reasoning-toggle';
                reasoningToggle.textContent = i18n('reasoningProcess');
                reasoningToggle.dataset.nodeId = node.id;
                
                const reasoningContent = document.createElement('div');
                reasoningContent.className = 'reasoning-content reasoning-collapsed';
                reasoningContent.dataset.nodeId = node.id;
                
                if (node.reasoning.includes('typing-indicator')) {
                    reasoningContent.innerHTML = node.reasoning;
                } else {
                    reasoningContent.textContent = node.reasoning;
                }
                
                const finalAnswer = document.createElement('div');
                finalAnswer.className = 'final-answer markdown-body';
                finalAnswer.style.marginTop = '8px';
                
                // Âè™Âú®ÊµÅÂºèËæìÂá∫ÂÆåÊàêÂêéÊ∏≤ÊüìMarkdown
                if (node.content.includes('typing-indicator')) {
                    finalAnswer.innerHTML = node.content;
                } else {
                    finalAnswer.innerHTML = marked.parse(node.content);
                }
                
                content.appendChild(reasoningToggle);
                content.appendChild(reasoningContent);
                content.appendChild(finalAnswer);
            } else {
                // Âè™Âú®ÊµÅÂºèËæìÂá∫ÂÆåÊàêÂêéÊ∏≤ÊüìMarkdown
                if (node.content.includes('typing-indicator')) {
                    content.innerHTML = node.content;
                } else {
                    content.innerHTML = marked.parse(node.content);
                }
            }
            
            element.appendChild(roleIndicator);
            element.appendChild(content);
            
            return element;
        }
        
        function updateNodeElement(element, node) {
            const content = element.querySelector('.node-content');
            
            // Á°Æ‰øùÁî®Êà∑ËäÇÁÇπÁöÑÈáçÂèëÊåâÈíÆÂ≠òÂú®
            if (node.role === 'user' && !element.querySelector('.resend-btn')) {
                const resendBtn = document.createElement('button');
                resendBtn.className = 'resend-btn';
                resendBtn.textContent = '‚Üª';
                resendBtn.title = i18n('resendTooltip');
                resendBtn.dataset.nodeId = node.id;
                element.appendChild(resendBtn);
            }
            
            // Á°Æ‰øùÂ§çÂà∂ÊåâÈíÆÂ≠òÂú®
            if (!element.querySelector('.copy-btn')) {
                const copyBtn = document.createElement('button');
                copyBtn.className = 'copy-btn';
                copyBtn.textContent = '‚éò';
                copyBtn.title = i18n('copyTooltip');
                copyBtn.dataset.nodeId = node.id;
                element.appendChild(copyBtn);
            }
            
            if (node.reasoning !== undefined && node.reasoning !== null) {
                let reasoningToggle = content.querySelector('.reasoning-toggle');
                let reasoningContent = content.querySelector('.reasoning-content');
                let finalAnswer = content.querySelector('.final-answer');
                
                if (!reasoningToggle) {
                    content.innerHTML = '';
                    
                    reasoningToggle = document.createElement('div');
                    reasoningToggle.className = 'reasoning-toggle';
                    reasoningToggle.textContent = i18n('reasoningProcess');
                    reasoningToggle.dataset.nodeId = node.id;
                    
                    reasoningContent = document.createElement('div');
                    reasoningContent.className = 'reasoning-content reasoning-collapsed';
                    reasoningContent.dataset.nodeId = node.id;
                    
                    finalAnswer = document.createElement('div');
                    finalAnswer.className = 'final-answer markdown-body';
                    finalAnswer.style.marginTop = '8px';
                    
                    content.appendChild(reasoningToggle);
                    content.appendChild(reasoningContent);
                    content.appendChild(finalAnswer);
                }
                
                if (node.reasoning.includes('typing-indicator')) {
                    reasoningContent.innerHTML = node.reasoning;
                } else {
                    reasoningContent.textContent = node.reasoning;
                }
                
                if (node.content.includes('typing-indicator')) {
                    finalAnswer.innerHTML = node.content;
                } else {
                    finalAnswer.innerHTML = marked.parse(node.content);
                }
            } else {
                if (node.content.includes('typing-indicator')) {
                    content.innerHTML = node.content;
                } else {
                    content.innerHTML = marked.parse(node.content);
                }
            }
            
            element.style.left = node.position.x + 'px';
            element.style.top = node.position.y + 'px';
        }
        
        function renderConnections() {
            const svg = elements.connections;
            svg.innerHTML = '';
            
            Object.values(state.conversation.nodes).forEach(node => {
                node.branches.forEach(branch => {
                    const targetNode = state.conversation.nodes[branch.nextNodeId];
                    if (targetNode) drawConnection(svg, node, targetNode);
                });
            });
        }
        
        function drawConnection(svg, fromNode, toNode) {
            const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
            
            const fromY = fromNode.position.y + CONSTANTS.NODE_HEIGHT[fromNode.role];
            const fromX = fromNode.position.x + CONSTANTS.NODE_WIDTH / 2;
            const toX = toNode.position.x + CONSTANTS.NODE_WIDTH / 2;
            const toY = toNode.position.y;
            
            const pathData = `M ${fromX} ${fromY} C ${fromX} ${fromY + 125}, ${toX} ${toY - 125}, ${toX} ${toY}`;
            path.setAttribute('d', pathData);
            
            const pathToSelected = getPathToNode(state.conversation.startNode, state.selectedNodeId);
            const inPath = pathToSelected.includes(fromNode.id) && pathToSelected.includes(toNode.id);
            
            path.setAttribute('stroke', inPath ? 'var(--primary-color)' : '#6c757d');
            path.setAttribute('stroke-width', inPath ? '2' : '1');
            path.setAttribute('fill', 'none');
            path.setAttribute('stroke-dasharray', inPath ? 'none' : '5,5');
            
            svg.appendChild(path);
        }
        
        function renderTreeView() {
            const treeView = elements.treeView;
            treeView.innerHTML = '';
            
            if (state.conversation.startNode) {
                const treeNode = createTreeNode(state.conversation.startNode);
                treeView.appendChild(treeNode);
            }
        }
        
        function createTreeNode(nodeId) {
            const node = state.conversation.nodes[nodeId];
            if (!node) return null;
            
            const li = document.createElement('li');
            
            const treeNode = document.createElement('div');
            treeNode.className = 'tree-node';
            
            const roleBadge = document.createElement('span');
            roleBadge.className = `badge ${node.role === 'system' ? 'bg-success' : node.role === 'user' ? 'bg-primary' : 'bg-info'} me-1`;
            roleBadge.textContent = node.role.substring(0, 1).toUpperCase();
            
            const content = document.createTextNode(
                node.content.length > 30 ? node.content.substring(0, 30) + '...' : node.content
            );
            
            treeNode.appendChild(roleBadge);
            treeNode.appendChild(content);
            treeNode.dataset.nodeId = nodeId;
            
            treeNode.addEventListener('click', (e) => {
                e.stopPropagation();
                selectNode(nodeId);
                scrollToNode(nodeId);
            });
            
            li.appendChild(treeNode);
            
            if (node.branches.length > 0) {
                const childList = document.createElement('ul');
                
                node.branches.forEach(branch => {
                    const childNode = createTreeNode(branch.nextNodeId);
                    if (childNode) childList.appendChild(childNode);
                });
                
                li.appendChild(childList);
            }
            
            return li;
        }
        
        // Â∑•ÂÖ∑ÂáΩÊï∞
        function calculateNodePosition(parentNode, nodeType) {
            const parentPos = parentNode.position;
            
            const children = Object.values(state.conversation.nodes).filter(node => 
                parentNode.branches.some(branch => branch.nextNodeId === node.id)
            );
            
            let newY = parentPos.y + CONSTANTS.VERTICAL_SPACING;
            let newX = parentPos.x;
            
            if (children.length > 0) {
                const avgX = children.reduce((sum, node) => sum + node.position.x, 0) / children.length;
                newX = avgX + (children.length * CONSTANTS.HORIZONTAL_SPACING);
                
                let attempts = 0;
                while (isOverlapping(newX, newY, nodeType) && attempts < 10) {
                    newX += CONSTANTS.HORIZONTAL_SPACING;
                    attempts++;
                }
            }
            
            return { x: newX, y: newY };
        }
        
        function isOverlapping(x, y, nodeType) {
            const nodeWidth = CONSTANTS.NODE_WIDTH + 20;
            const nodeHeight = CONSTANTS.NODE_HEIGHT[nodeType];
            
            return Object.values(state.conversation.nodes).some(node => {
                const existingNodeHeight = CONSTANTS.NODE_HEIGHT[node.role];
                
                return (
                    x < node.position.x + nodeWidth && 
                    x + nodeWidth > node.position.x && 
                    y < node.position.y + existingNodeHeight && 
                    y + nodeHeight > node.position.y
                );
            });
        }
        
        function getContextMessages(nodeId) {
            const path = getPathToNode(state.conversation.startNode, nodeId);
            return path.map(id => {
                const node = state.conversation.nodes[id];
                return { role: node.role, content: node.content };
            });
        }
        
        function getPathToNode(startNodeId, targetNodeId, path = []) {
            if (!startNodeId) return [];
            
            path.push(startNodeId);
            
            if (startNodeId === targetNodeId) return path;
            
            const node = state.conversation.nodes[startNodeId];
            for (let branch of node.branches) {
                const result = getPathToNode(branch.nextNodeId, targetNodeId, [...path]);
                if (result.length > 0) return result;
            }
            
            return [];
        }
        
        function selectNode(nodeId) {
            state.selectedNodeId = nodeId;
            updateSelection();
            updateUI();
            updateContextInfo();
            renderConnections();
            saveStateToLocalStorage();
        }
        
        function updateSelection() {
            const path = getPathToNode(state.conversation.startNode, state.selectedNodeId);
            
            Object.values(state.conversation.nodes).forEach(node => {
                const element = document.getElementById(node.id);
                if (!element) return;
                
                const inPath = path.includes(node.id);
                
                if (node.id === state.selectedNodeId) {
                    element.classList.add('selected');
                    element.classList.remove('muted');
                } else if (inPath) {
                    element.classList.remove('selected');
                    element.classList.remove('muted');
                } else {
                    element.classList.remove('selected');
                    element.classList.add('muted');
                }
            });
            
            document.querySelectorAll('.tree-node').forEach(treeNode => {
                treeNode.classList.toggle('selected', treeNode.dataset.nodeId === state.selectedNodeId);
            });
        }
        
        function updateUI() {
            const hasSelection = state.selectedNodeId !== null;
            elements.deleteNodeBtn.disabled = !hasSelection;
            elements.sendBtn.disabled = !hasSelection;
        }
        
        function updateContextInfo() {
            if (!state.selectedNodeId) {
                elements.contextInfo.textContent = '0';
                return;
            }
            
            const path = getPathToNode(state.conversation.startNode, state.selectedNodeId);
            elements.contextInfo.textContent = path.length;
        }
        
        function editNodeContent(nodeId) {
            const node = state.conversation.nodes[nodeId];
            
            if (node.reasoning !== undefined && node.reasoning !== null) {
                const newContent = prompt(i18n('editFinalAnswer'), node.content);
                if (newContent !== null) {
                    node.content = newContent;
                    renderAll();
                    saveStateToLocalStorage();
                }
            } else {
                const newContent = prompt(i18n('editNodeContent'), node.content);
                if (newContent !== null) {
                    node.content = newContent;
                    renderAll();
                    saveStateToLocalStorage();
                }
            }
        }
        
        function toggleReasoning(nodeId) {
            const nodeElement = document.getElementById(nodeId);
            if (!nodeElement) return;
            
            const reasoningContent = nodeElement.querySelector('.reasoning-content');
            if (!reasoningContent) return;
            
            reasoningContent.classList.toggle('reasoning-collapsed');
        }
        
        function copyNodeContent(nodeId) {
            const node = state.conversation.nodes[nodeId];
            if (!node) return;
            
            // ÁÆÄÂåñÂ§çÂà∂ÈÄªËæë - Áõ¥Êé•Â§çÂà∂ÂÜÖÂÆπ
            let textToCopy = node.content;
            
            // Â¶ÇÊûúËäÇÁÇπÂÜÖÂÆπÂåÖÂê´MarkdownÔºåÊàë‰ª¨ÈúÄË¶ÅËé∑ÂèñÁ∫ØÊñáÊú¨
            const tempElement = document.createElement('div');
            tempElement.innerHTML = node.content;
            textToCopy = tempElement.textContent || tempElement.innerText || '';
            
            // ‰ΩøÁî®Clipboard APIÂ§çÂà∂ÊñáÊú¨
            navigator.clipboard.writeText(textToCopy).then(() => {
                showCopySuccess(nodeId);
            }).catch(err => {
                console.error('Copy failed:', err);
                // Â§áÁî®ÊñπÊ≥ï
                const textArea = document.createElement('textarea');
                textArea.value = textToCopy;
                document.body.appendChild(textArea);
                textArea.select();
                document.execCommand('copy');
                document.body.removeChild(textArea);
                showCopySuccess(nodeId);
            });
        }
        
        function showCopySuccess(nodeId) {
            const nodeElement = document.getElementById(nodeId);
            if (!nodeElement) return;
            
            let successElement = nodeElement.querySelector('.copy-success');
            if (!successElement) {
                successElement = document.createElement('div');
                successElement.className = 'copy-success mt-1';
                successElement.textContent = i18n('copySuccess');
                nodeElement.appendChild(successElement);
            }
            
            successElement.classList.add('show');
            
            setTimeout(() => {
                successElement.classList.remove('show');
            }, 2000);
        }
        
        function makeDraggable(element, node) {
            element.addEventListener('mousedown', startDrag);
            
            function startDrag(e) {
                if (e.target.classList.contains('node-content') || 
                    e.target.classList.contains('reasoning-content') ||
                    e.target.classList.contains('final-answer') ||
                    e.target.classList.contains('reasoning-toggle') ||
                    e.target.classList.contains('resend-btn') ||
                    e.target.classList.contains('copy-btn')) return;
                
                state.isDragging = true;
                state.dragStart.x = e.clientX;
                state.dragStart.y = e.clientY;
                const initialX = element.offsetLeft;
                const initialY = element.offsetTop;
                
                function drag(e) {
                    if (!state.isDragging) return;
                    
                    const dx = e.clientX - state.dragStart.x;
                    const dy = e.clientY - state.dragStart.y;
                    
                    const newX = initialX + dx;
                    const newY = initialY + dy;
                    
                    element.style.left = newX + 'px';
                    element.style.top = newY + 'px';
                    
                    node.position.x = newX;
                    node.position.y = newY;
                    
                    renderConnections();
                }
                
                function stopDrag() {
                    state.isDragging = false;
                    document.removeEventListener('mousemove', drag);
                    document.removeEventListener('mouseup', stopDrag);
                    saveStateToLocalStorage();
                }
                
                document.addEventListener('mousemove', drag);
                document.addEventListener('mouseup', stopDrag);
                
                e.preventDefault();
            }
        }
        
        function scrollToNode(nodeId) {
            const nodeElement = document.getElementById(nodeId);
            if (!nodeElement) return;
            
            const node = state.conversation.nodes[nodeId];
            const nodeX = node.position.x + CONSTANTS.NODE_WIDTH / 2;
            const nodeY = node.position.y + CONSTANTS.NODE_HEIGHT[node.role] / 2;
            const container = document.getElementById('canvasContainer');
            
            const scrollX = nodeX * state.zoomLevel - container.clientWidth / 2;
            const scrollY = nodeY * state.zoomLevel - container.clientHeight / 2;
            
            container.scrollTo(scrollX, scrollY);
        }
        
        function adjustZoom(delta) {
            state.zoomLevel = Math.max(0.3, Math.min(3, state.zoomLevel + delta));
            elements.canvas.style.transform = `scale(${state.zoomLevel})`;
            renderConnections();
        }
        
        function resetZoom() {
            state.zoomLevel = 1;
            elements.canvas.style.transform = 'scale(1)';
            renderConnections();
        }
        
        // Êï∞ÊçÆÊåÅ‰πÖÂåñ
        function saveStateToLocalStorage() {
            try {
                const stateToSave = {
                    conversation: state.conversation,
                    selectedNodeId: state.selectedNodeId,
                    zoomLevel: state.zoomLevel,
                    apiSettings: {
                        apiUrl: document.getElementById('apiUrl').value,
                        apiKey: document.getElementById('apiKey').value,
                        modelName: document.getElementById('modelName').value,
                        temperature: document.getElementById('temperature').value
                    }
                };
                
                localStorage.setItem('vibechat-state', JSON.stringify(stateToSave));
            } catch (error) {
                console.error('Failed to save to localStorage:', error);
            }
        }
        
        function loadStateFromLocalStorage() {
            try {
                const savedState = localStorage.getItem('vibechat-state');
                if (savedState) {
                    const parsedState = JSON.parse(savedState);
                    
                    if (parsedState.conversation) {
                        state.conversation = parsedState.conversation;
                    }
                    
                    if (parsedState.selectedNodeId) {
                        state.selectedNodeId = parsedState.selectedNodeId;
                    }
                    
                    if (parsedState.zoomLevel) {
                        state.zoomLevel = parsedState.zoomLevel;
                        elements.canvas.style.transform = `scale(${state.zoomLevel})`;
                    }
                    
                    if (parsedState.apiSettings) {
                        document.getElementById('apiUrl').value = parsedState.apiSettings.apiUrl || 'https://api.deepseek.com/chat/completions';
                        document.getElementById('apiKey').value = parsedState.apiSettings.apiKey || '';
                        document.getElementById('modelName').value = parsedState.apiSettings.modelName || 'deepseek-chat';
                        document.getElementById('temperature').value = parsedState.apiSettings.temperature || '1.0';
                    }
                }
            } catch (error) {
                console.error('Failed to restore state from localStorage:', error);
            }
        }
        
        function exportConversation() {
            const now = new Date();
            const timestamp = `${now.getFullYear()}${(now.getMonth()+1).toString().padStart(2, '0')}${now.getDate().toString().padStart(2, '0')}_${now.getHours().toString().padStart(2, '0')}${now.getMinutes().toString().padStart(2, '0')}${now.getSeconds().toString().padStart(2, '0')}`;
            
            const exportData = {
                title: `VibeChat_${timestamp}`,
                nodes: {},
                startNode: state.conversation.startNode
            };
            
            Object.values(state.conversation.nodes).forEach(node => {
                exportData.nodes[node.id] = {
                    id: node.id,
                    role: node.role,
                    content: node.content,
                    reasoning: node.reasoning,
                    branches: node.branches
                };
            });
            
            const dataStr = JSON.stringify(exportData, null, 2);
            const dataBlob = new Blob([dataStr], {type: 'application/json'});
            
            const link = document.createElement('a');
            link.href = URL.createObjectURL(dataBlob);
            link.download = `VibeChat_${timestamp}.json`;
            link.click();
        }
        
        function importConversation(event) {
            const file = event.target.files[0];
            if (!file) return;
            
            const reader = new FileReader();
            reader.onload = function(e) {
                try {
                    const importedData = JSON.parse(e.target.result);
                    
                    if (importedData.nodes && importedData.startNode) {
                        state.conversation = {
                            title: importedData.title || 'VibeChat',
                            nodes: {},
                            startNode: importedData.startNode
                        };
                        
                        Object.values(importedData.nodes).forEach(node => {
                            state.conversation.nodes[node.id] = {
                                id: node.id,
                                role: node.role || 'user',
                                content: node.content,
                                reasoning: node.reasoning,
                                branches: node.branches,
                                position: { x: 0, y: 0 }
                            };
                        });
                        
                        autoArrangeNodes();
                        state.selectedNodeId = null;
                        renderAll();
                        saveStateToLocalStorage();
                        
                        alert(i18n('importSuccess'));
                    } else {
                        alert(i18n('invalidFormat'));
                    }
                } catch (error) {
                    alert(i18n('importFailed') + error.message);
                }
                
                event.target.value = '';
            };
            reader.readAsText(file);
        }
        
        function autoArrangeNodes() {
            if (!state.conversation.startNode) return;
            
            const queue = [{nodeId: state.conversation.startNode, depth: 0}];
            const visited = new Set();
            const depthMap = {};
            
            while (queue.length > 0) {
                const {nodeId, depth} = queue.shift();
                
                if (visited.has(nodeId)) continue;
                visited.add(nodeId);
                
                if (!depthMap[depth]) depthMap[depth] = [];
                depthMap[depth].push(nodeId);
                
                const node = state.conversation.nodes[nodeId];
                node.branches.forEach(branch => {
                    queue.push({nodeId: branch.nextNodeId, depth: depth + 1});
                });
            }
            
            const maxDepth = Math.max(...Object.keys(depthMap).map(Number));
            
            for (let depth = 0; depth <= maxDepth; depth++) {
                const nodesAtDepth = depthMap[depth] || [];
                const count = nodesAtDepth.length;
                
                const startX = 2500 - (count * CONSTANTS.HORIZONTAL_SPACING) / 2;
                
                nodesAtDepth.forEach((nodeId, index) => {
                    state.conversation.nodes[nodeId].position = {
                        x: startX + index * CONSTANTS.HORIZONTAL_SPACING,
                        y: 200 + depth * CONSTANTS.VERTICAL_SPACING
                    };
                });
            }
        }
    </script>
</body>
</html>
