<!DOCTYPE html>
<html lang="zh-CN" data-theme="cupcake">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>VibeChat(α) | Multi-branch LLM WebChat</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Doto:wght@100..900&display=swap" rel="stylesheet">
    <script src="https://cdn.tailwindcss.com?plugins=typography"></script>
    <script>
        tailwind.config = {
            darkMode: ['class', '[data-theme="dark"]'],
            theme: {
                extend: {
                    fontFamily: {
                        'doto': ['Doto', 'sans-serif'],
                        'sans': ['Microsoft Yahei UI', 'Segoe UI', 'Tahoma', 'Geneva', 'Verdana', 'sans-serif'],
                    }
                }
            }
        }
    </script>
    <link href="https://cdn.jsdelivr.net/npm/daisyui@4.12.14/dist/full.min.css" rel="stylesheet" type="text/css" />
    <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
    
    <style>
        :root {
            --node-width: 450px;
            --node-height-user: 150px;
            --node-height-assistant: 250px;
            --node-height-system: 150px;
            --horizontal-spacing: 300;
            --vertical-spacing: 250;
        }

        .vibe-font { font-family: 'Doto', sans-serif; font-weight: 700; }
        
        .app-container {
            background-color: oklch(var(--b3));
        }
        
        [data-theme="dark"] .app-container {
            background-color: oklch(var(--b2));
        }
        
        .sidebar {
            background-color: oklch(var(--b2));
            height: 100vh;
            overflow-y: auto;
        }
        
        [data-theme="dark"] .sidebar {
            background-color: oklch(var(--b1));
        }
        
        .story-canvas-container {
            position: relative;
            flex: 1;
            overflow: auto;
            background-color: oklch(var(--b3));
            scrollbar-width: thin;
            scrollbar-color: oklch(var(--bc) / 0.3) transparent;
        }
        
        .story-canvas-container::-webkit-scrollbar {
            width: 8px;
            height: 8px;
        }
        
        .story-canvas-container::-webkit-scrollbar-track {
            background: transparent;
        }
        
        .story-canvas-container::-webkit-scrollbar-thumb {
            background-color: oklch(var(--bc) / 0.3);
            border-radius: 4px;
        }
        
        .story-canvas-container::-webkit-scrollbar-thumb:hover {
            background-color: oklch(var(--bc) / 0.5);
        }
        
        [data-theme="forest"] .story-canvas-container {
            background-color: oklch(var(--b2));
            scrollbar-color: oklch(var(--bc) / 0.2) transparent;
        }
        .story-canvas { 
            position: relative; 
            width: 5000px; 
            height: 5000px; 
            background-color: oklch(var(--b3)); 
            background-image: linear-gradient(oklch(var(--bc) / 0.1) 1px, transparent 1px), linear-gradient(90deg, oklch(var(--bc) / 0.1) 1px, transparent 1px);
            background-size: 20px 20px; 
            transform-origin: 0 0; 
            transition: transform 0.1s ease; 
        }
        
        [data-theme="dark"] .story-canvas {
            background-color: oklch(var(--b2));
            background-image: linear-gradient(oklch(var(--bc) / 0.1) 1px, transparent 1px), linear-gradient(90deg, oklch(var(--bc) / 0.1) 1px, transparent 1px);
        }
        
        .node { 
            position: absolute; 
            width: var(--node-width); 
            cursor: move; 
            transition: all 0.2s; 
            z-index: 10; 
        }
        
        .node-content { 
            font-size: 14px; 
            word-break: break-word; 
            overflow-y: auto; 
        }
        
        .node.system { border-left: 5px solid oklch(var(--su)); }
        .node.user { border-left: 5px solid oklch(var(--p)); }
        .node.assistant { border-left: 5px solid oklch(var(--s)); }
        
        .node.selected { 
            z-index: 20; 
            outline: 2px solid oklch(var(--p));
            outline-offset: 2px;
        }
        
        .node.muted { opacity: 0.55; }
        
        .connections { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; z-index: 5; }
        
        .tree-view { 
            list-style-type: none; 
            padding-left: 0; 
            min-width: 200px; 
            overflow-x: auto; 
        }
        .tree-view ul { list-style-type: none; padding-left: 20px; }
        .tree-node { 
            padding: 5px 10px; 
            cursor: pointer; 
            border-radius: 4px; 
            margin-bottom: 2px; 
            min-width: 200px; 
            font-size: .75em; 
        }
        .tree-node:hover { background-color: oklch(var(--b3) / 0.5); }
        .tree-node.selected { background-color: oklch(var(--p) / 0.3); }
        
        .zoom-controls { position: absolute; top: 20px; right: 20px; z-index: 100; }
        
        .chat-input-container { 
            padding: 20px; 
            border-top: 1px solid oklch(var(--bc) / 0.1); 
            z-index: 100; 
            flex-shrink: 0; 
            background-color: oklch(var(--b2));
            min-height: 80px;
        }
        
        [data-theme="dark"] .chat-input-container {
            background-color: oklch(var(--b1));
        }
        
        .typing-indicator { 
            display: inline-block; 
            width: 10px; 
            height: 10px; 
            background-color: oklch(var(--bc) / 0.5); 
            border-radius: 50%; 
            margin-right: 5px; 
            animation: typing 1s infinite; 
        }
        
        @keyframes typing { 
            0%, 100% { opacity: 0.3; } 
            50% { opacity: 1; } 
        }
        
        .reasoning-content { 
            background-color: oklch(var(--b3)); 
            border: 1px solid oklch(var(--bc) / 0.1); 
            border-radius: 4px; 
            padding: 8px; 
            margin-bottom: 8px; 
            font-size: 13px; 
            color: oklch(var(--bc) / 0.7); 
            max-height: 120px; 
            overflow-y: auto; 
        }
        
        .reasoning-toggle { 
            font-size: 12px; 
            color: oklch(var(--bc) / 0.7); 
            cursor: pointer; 
            user-select: none; 
            margin-bottom: 5px; 
            display: inline-block; 
        }
        
        .reasoning-collapsed { max-height: 55px; overflow: hidden; }
        .reasoning-collapsed::after { content: "..."; display: block; text-align: center; }
        
        .node-btn { 
            position: absolute; 
            top: 5px; 
            background: oklch(var(--b1)); 
            border: 1px solid oklch(var(--bc) / 0.2); 
            border-radius: 4px; 
            padding: 2px 6px; 
            font-size: 10px; 
            cursor: pointer; 
            z-index: 15; 
            opacity: 0; 
            transition: opacity 0.2s; 
        }
        
        .node:hover .node-btn { opacity: 1; }
        .resend-btn { right: 30px; }
        .resend-btn:hover { background-color: oklch(var(--p)); color: white; }
        .copy-btn { right: 5px; }
        .copy-btn:hover { background-color: oklch(var(--su)); color: white; }
        
        .copy-success { 
            position: absolute; 
            top: 5px; 
            left: 50%; 
            transform: translateX(-50%); 
            background-color: oklch(var(--in)); 
            color: white; 
            padding: 2px 6px; 
            border-radius: 4px; 
            font-size: 10px; 
            z-index: 15; 
            opacity: 0; 
            transition: opacity 0.2s; 
        }
        
        .copy-success.show { opacity: 1; }
        
        .node-content { font-size: 14px; line-height: 1.5; word-wrap: break-word; }
        .node-content h1, .node-content h2, .node-content h3, .node-content h4, .node-content h5, .node-content h6 { margin-top: 0.5em; margin-bottom: 0.3em; font-weight: 600; line-height: 1.25; }
        .node-content h1 { font-size: 1.5rem !important; }
        .node-content h2 { font-size: 1.3rem !important; }
        .node-content h3 { font-size: 1.2rem !important; }
        .node-content h4 { font-size: 1.1rem !important; }
        .node-content h5 { font-size: 1.05rem !important; }
        .node-content h6 { font-size: 1rem !important; color: oklch(var(--bc) / 0.7) !important; }
        .node-content p { margin-bottom: 0.5em; }
        .node-content ul, .node-content ol { padding-left: 1.5em; margin-bottom: 0.5em; }
        .node-content li { margin-bottom: 0.2em; }
        .node-content code { background-color: oklch(var(--b3)); border-radius: 3px; padding: 0.1em 0.3em; font-size: 0.9em; }
        .node-content pre { background-color: oklch(var(--b3)); border: 1px solid oklch(var(--bc) / 0.1); border-radius: 4px; padding: 0.8em; overflow: auto; margin-bottom: 0.8em; }
        .node-content pre code { background: none; padding: 0; }
        .node-content blockquote { border-left: 4px solid oklch(var(--bc) / 0.2); padding-left: 1em; margin-left: 0; color: oklch(var(--bc) / 0.7); margin-bottom: 0.8em; }
        .node-content table { border-collapse: collapse; width: 100%; margin-bottom: 0.8em; }
        .node-content table th, .node-content table td { border: 1px solid oklch(var(--bc) / 0.1); padding: 0.3em 0.5em; text-align: left; }
        .node-content table th { background-color: oklch(var(--b3)); font-weight: 600; }
        
        .tree-node.has-children { position: relative; }
        .tree-toggle { 
            position: absolute; 
            left: -15px; 
            top: 50%; 
            transform: translateY(-50%); 
            width: 12px; 
            height: 12px; 
            cursor: pointer; 
            font-size: 10px; 
            display: flex; 
            align-items: center; 
            justify-content: center; 
        }
        .tree-children { transition: max-height 0.3s ease; overflow: hidden; }
        .tree-children.collapsed { max-height: 0; }
        
        .conversations-list { max-height: 300px; overflow-y: auto; margin-bottom: 15px; }
        .conversation-item { 
            display: flex; 
            justify-content: space-between; 
            align-items: center; 
            padding: 8px 10px; 
            border-radius: 4px; 
            margin-bottom: 5px; 
            background-color: oklch(var(--b3) / 0.3); 
        }
        .conversation-item:hover { background-color: oklch(var(--b3) / 0.5); }
        .conversation-title { flex-grow: 1; cursor: pointer; overflow: hidden; text-overflow: ellipsis; white-space: nowrap; }
        .conversation-actions { display: flex; gap: 5px; }
        
        .sidebar { 
            background-color: oklch(var(--b3)); 
            height: 100vh; 
            overflow-y: auto; 
        }
        
        #sidebar {
            background-color: oklch(var(--b2));
        }
        
        [data-theme="dark"] .sidebar {
            background-color: oklch(var(--b2));
        }
        
        .chat-input-container {
            background-color: oklch(var(--b2));
        }
        
        [data-theme="dark"] .chat-input-container {
            background-color: oklch(var(--b1));
        }
        
        @media (max-width: 1024px) {
            .sidebar {
                position: fixed;
                top: 0;
                left: 0;
                width: 85%;
                max-width: 300px;
                z-index: 50;
                box-shadow: 2px 0 10px rgba(0,0,0,0.3);
            }
            
            .sidebar-overlay {
                display: none;
                position: fixed;
                top: 0;
                left: 0;
                width: 100%;
                height: 100%;
                background: rgba(0, 0, 0, 0.5);
                z-index: 40;
            }
            
            .sidebar-overlay.active {
                display: block;
            }
            
            .node {
                width: 90%;
                max-width: 400px;
            }
            
            .zoom-controls {
                right: 10px;
            }
            
            .chat-input-container {
                padding: 15px;
            }
            
            .mobile-menu-btn {
                display: flex !important;
            }
            
            .toolbar {
                left: 20px !important;
            }
        }
        
        .mobile-menu-btn {
            display: none;
        }
        
        @media (min-width: 1024px) {
            .toolbar {
                left: 340px !important;
            }
            .story-canvas-container, .chat-input-container {
                margin-left: 0;
            }
        }
        
        @media (max-width: 576px) {
            .node {
                width: 95%;
                max-width: 350px;
            }
            
            .chat-input-container {
                padding: 10px;
            }
        }
    </style>
</head>
<body>
    <div class="sidebar-overlay" id="sidebarOverlay"></div>
    
    <div class="app-container flex h-screen">
        <!-- Sidebar -->
        <aside class="sidebar w-80 flex-shrink-0 hidden lg:flex flex-col" id="sidebar">
            <div class="p-4">
                <h3 class="mb-4 vibe-font text-lg">
                    VibeChat<sup><a href="https://github.com/DreamBlooms/VibeChat" target="_blank" class="link link-hover">(a)</a></sup>
                </h3>
                
                <div class="collapse collapse-arrow bg-base-300 mb-4 rounded-lg">
                    <input type="checkbox" checked /> 
                    <div class="collapse-title font-medium min-h-0">
                        <small data-i18n="apiSettings">API 设置</small>
                    </div>
                    <div class="collapse-content"> 
                        <div class="form-control">
                            <label class="label py-1">
                                <span class="label-text text-sm" data-i18n="apiUrl">API地址</span>
                            </label>
                            <input type="text" class="input input-sm input-bordered" id="apiUrl" value="https://api.deepseek.com/chat/completions" autocomplete="off">
                        </div>
                        <div class="form-control mt-2">
                            <label class="label py-1">
                                <span class="label-text text-sm" data-i18n="apiKey">API密钥</span>
                            </label>
                            <input type="password" class="input input-sm input-bordered" id="apiKey" placeholder="输入API密钥" data-i18n-placeholder="apiKeyPlaceholder" autocomplete="off">
                        </div>
                        <div class="form-control mt-2">
                            <label class="label py-1">
                                <span class="label-text text-sm" data-i18n="modelName">模型名称</span>
                            </label>
                            <input type="text" class="input input-sm input-bordered" id="modelName" list="modelOptions" value="deepseek-chat" placeholder="输入模型名称" data-i18n-placeholder="modelNamePlaceholder" autocomplete="off">
                            <datalist id="modelOptions">
                                <option value="deepseek-chat">
                                <option value="deepseek-reasoner">
                            </datalist>
                        </div>
                        <div class="form-control mt-2">
                            <label class="label py-1">
                                <span class="label-text text-sm" data-i18n="temperature">温度<small> (0.1-2.0)</small></span>
                            </label>
                            <input type="number" class="input input-sm input-bordered" id="temperature" min="0" max="2" step="0.1" value="1.0" autocomplete="off">
                        </div>
                        <button class="btn btn-outline btn-sm w-full mt-3" id="testApiBtn" data-i18n="testConnection">测试连接</button>
                    </div>
                </div>
                    
                <div class="tabs tabs-boxed bg-base-100 mb-4">
                    <a class="tab tab-active flex-1" id="treeview-tab" data-i18n="treeView">对话树</a>
                    <a class="tab flex-1" id="conversations-tab" data-i18n="conversationManagement">对话管理</a>
                </div>
                
                <div id="treeview-content">
                    <ul class="tree-view" id="treeView"></ul>
                </div>
                
                <div id="conversations-content" class="hidden">
                    <div class="flex gap-2 mb-3">
                        <button class="btn btn-outline btn-sm flex-1" id="newConversationBtn" data-i18n="newBtn">新建</button>
                        <button class="btn btn-outline btn-sm flex-1" id="exportBtn" data-i18n="exportBtn">导出</button>
                        <button class="btn btn-outline btn-sm flex-1" id="importBtn" data-i18n="importBtn">导入</button>
                    </div>
                    <input type="file" id="importFile" style="display: none;" accept=".json">
                    
                    <div class="divider my-2"></div>
                    
                    <div class="conversations-list" id="conversationsList">
                    </div>
                </div>
            </div>
        </aside>
        
        <!-- Main Content -->
        <main class="flex-1 flex flex-col min-w-0">
            <!-- Toolbar -->
            <div class="toolbar absolute top-5 left-5 z-[100]">
                <div class="join">
                    <button class="btn btn-sm btn-ghost mobile-menu-btn" id="mobileMenuBtn" title="菜单">
                        <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 6h16M4 12h16M4 18h16" />
                        </svg>
                    </button>
                    <button class="btn btn-sm btn-ghost" id="themeToggle" title="日之亮面">
                        <svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M20.354 15.354A9 9 0 018.646 3.646 9.003 9.003 0 0012 21a9.003 9.003 0 008.354-5.646z" />
                        </svg>
                    </button>
                    <button class="btn btn-sm btn-ghost" id="clearConversationBtn" title="清空对话">
                        <svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 7l-.867 12.142A2 2 0 0116.138 21H7.862a2 2 0 01-1.995-1.858L5 7m5 4v6m4-6v6m1-10V4a1 1 0 00-1-1h-4a1 1 0 00-1 1v3M4 7h16" />
                        </svg>
                    </button>
                    <button class="btn btn-sm btn-error text-white" id="deleteNodeBtn" data-i18n="deleteNode">删除节点</button>
                </div>
            </div>
            
            <!-- Canvas -->
            <div class="story-canvas-container flex-1" id="canvasContainer">
                <div class="story-canvas" id="storyCanvas">
                    <svg class="connections" id="connections"></svg>
                </div>
            </div>
            
            <!-- Zoom Controls -->
            <div class="zoom-controls">
                <div class="join join-vertical shadow-lg">
                    <button class="btn btn-sm btn-ghost bg-base-100 mb-1" id="zoomInBtn">+</button>
                    <button class="btn btn-sm btn-ghost bg-base-100 mb-1" id="zoomOutBtn">-</button>
                    <button class="btn btn-sm btn-ghost bg-base-100 mb-1" id="resetZoomBtn">↻</button>
                </div>
            </div>
            
            <!-- Chat Input -->
            <div class="chat-input-container">
                <div class="join w-full">
                    <input type="text" class="input input-bordered join-item flex-1" id="userInput" placeholder="输入您的问题..." autocomplete="off" data-i18n-placeholder="inputPlaceholder">
                    <button class="btn btn-primary join-item" id="sendBtn" data-i18n="sendBtn">发送</button>
                </div>
                <small class="text-base-content/60 mt-2 block">
                    <span data-i18n="selectedNode">选中节点:</span> <span id="contextInfo">1</span>
                </small>
            </div>
        </main>
    </div>

    <script>
        marked.setOptions({
            breaks: true,
            gfm: true,
            headerIds: false,
            mangle: false
        });
        
        const CONSTANTS = {
            HORIZONTAL_SPACING: 300,
            VERTICAL_SPACING: 250,
            NODE_WIDTH: 450,
            NODE_HEIGHT: {
                user: 150,
                assistant: 250,
                system: 150
            }
        };
        
        const state = {
            conversations: {},
            currentConversationId: null,
            isDragging: false,
            dragStart: { x: 0, y: 0 },
            isMobile: window.innerWidth <= 1024
        };
        
        const elements = {
            canvas: document.getElementById('storyCanvas'),
            connections: document.getElementById('connections'),
            treeView: document.getElementById('treeView'),
            contextInfo: document.getElementById('contextInfo'),
            userInput: document.getElementById('userInput'),
            sendBtn: document.getElementById('sendBtn'),
            deleteNodeBtn: document.getElementById('deleteNodeBtn'),
            clearConversationBtn: document.getElementById('clearConversationBtn'),
            sidebar: document.getElementById('sidebar'),
            sidebarOverlay: document.getElementById('sidebarOverlay'),
            mobileMenuBtn: document.getElementById('mobileMenuBtn'),
            themeToggle: document.getElementById('themeToggle'),
            conversationsList: document.getElementById('conversationsList'),
            newConversationBtn: document.getElementById('newConversationBtn'),
            treeviewTab: document.getElementById('treeview-tab'),
            conversationsTab: document.getElementById('conversations-tab'),
            treeviewContent: document.getElementById('treeview-content'),
            conversationsContent: document.getElementById('conversations-content')
        };

        const i18nResources = {
            'zh-CN': {
                pageTitle: 'VibeChat(α) | 多分支 LLM 网页聊天',
                exportBtn: '导出',
                importBtn: '导入',
                apiSettings: 'API 设置',
                apiUrl: 'API 地址',
                apiKey: 'API 密钥',
                apiKeyPlaceholder: '输入API密钥',
                modelName: '模型名称',
                modelNamePlaceholder: '输入模型名称',
                temperature: '温度',
                testConnection: '测试连接',
                deleteNode: '删除节点',
                inputPlaceholder: '输入您的问题...',
                sendBtn: '发送',
                selectedNode: '选中节点:',
                confirmDelete: '确定要删除这个节点及其所有子节点吗？',
                confirmClear: '确定要清空对话吗？这将删除所有节点，只保留系统提示消息。',
                confirmClearAgain: '再次确认：这将永久删除所有对话内容，只保留系统节点。',
                clearedAlert: '对话已清空，只保留系统提示消息。',
                enterQuestion: '请输入问题',
                selectNode: '请先选择一个节点',
                setApi: '请设置API地址和API密钥',
                resendUserOnly: '只能在用户节点上重发',
                apiSuccess: 'API连接成功！',
                apiUnexpected: 'API连接测试完成，但响应不符合预期。API路径需要至聊天完成为止。',
                importSuccess: '对话导入成功！',
                invalidFormat: '无效的对话文件格式',
                importFailed: '导入失败：',
                system: 'System',
                user: 'User',
                assistant: 'Assistant',
                assistantReply: '助手回复',
                reasoningProcess: '⇅ 推理过程',
                resendTooltip: '重发此消息',
                copyTooltip: '复制内容',
                copySuccess: '复制成功',
                darkThemeTooltip: '月之暗面',
                lightThemeTooltip: '日之亮面',
                clearConversationTitle: '清空对话',
                systemPrompt: '你是一个有用的AI助手。',
                testMessage: '请回复"连接成功"以确认API连接正常。',
                cannotDeleteStart: '不能删除起始节点',
                sending: '发送中...',
                testing: '测试中...',
                editFinalAnswer: '编辑节点最终回答:',
                editNodeContent: '编辑节点内容:',
                newConversation: '新建对话',
                renameConversation: '重命名',
                deleteConversation: '删除',
                switchConversation: '切换对话',
                confirmDeleteConversation: '确定要删除这个对话吗？此操作无法撤销。',
                enterConversationTitle: '请输入对话标题',
                defaultConversationTitle: '新对话',
                sendFailed: '发送失败：',
                resendFailed: '重发失败：',
                apiFailed: 'API连接失败：',
                treeView: '对话树',
                conversationManagement: '对话管理',
                newBtn: '新建',
                newConversation: '新对话',
                oldConversation: '旧对话'
            },
            'zh-TW': {
                pageTitle: 'VibeChat(α) | 多分支 LLM 網頁聊天',
                exportBtn: '導出',
                importBtn: '導入',
                apiSettings: 'API 設置',
                apiUrl: 'API 地址',
                apiKey: 'API 密鑰',
                apiKeyPlaceholder: '輸入API密鑰',
                modelName: '模型名稱',
                modelNamePlaceholder: '輸入模型名稱',
                temperature: '溫度',
                testConnection: '測試連接',
                deleteNode: '刪除節點',
                inputPlaceholder: '輸入您的問題...',
                sendBtn: '發送',
                selectedNode: '選中節點:',
                confirmDelete: '確定要刪除這個節點及其所有子節點嗎？',
                confirmClear: '確定要清空對話嗎？這將刪除所有節點，只保留系統提示消息。',
                confirmClearAgain: '再次確認：這將永久刪除所有對話內容，只保留系統節點。',
                clearedAlert: '對話已清空，只保留系統提示消息。',
                enterQuestion: '請輸入問題',
                selectNode: '請先選擇一個節點',
                setApi: '請設置API地址和API密鑰',
                resendUserOnly: '只能在用戶節點上重發',
                apiSuccess: 'API連接成功！',
                apiUnexpected: 'API連接測試完成，但響應不符合預期。API路徑需要至聊天完成爲止。',
                importSuccess: '對話導入成功！',
                invalidFormat: '無效的對話文件格式',
                importFailed: '導入失敗：',
                system: 'System',
                user: 'User',
                assistant: 'Assistant',
                assistantReply: '助手回覆',
                reasoningProcess: '⇅ 推理過程',
                resendTooltip: '重發此消息',
                copyTooltip: '複製內容',
                copySuccess: '複製成功',
                darkThemeTooltip: '月之暗面',
                lightThemeTooltip: '日之亮面',
                clearConversationTitle: '清空對話',
                systemPrompt: '你是一個有用的AI助手。',
                testMessage: '請回復"連接成功"以確認API連接正常。',
                cannotDeleteStart: '不能刪除起始節點',
                sending: '發送中...',
                testing: '測試中...',
                editFinalAnswer: '編輯節點最終回答:',
                editNodeContent: '編輯節點內容:',
                newConversation: '新建對話',
                renameConversation: '重命名',
                deleteConversation: '刪除',
                switchConversation: '切換對話',
                confirmDeleteConversation: '確定要刪除這個對話嗎？此操作無法撤銷。',
                enterConversationTitle: '請輸入對話標題',
                defaultConversationTitle: '新對話',
                sendFailed: '發送失敗：',
                resendFailed: '重發失敗：',
                apiFailed: 'API連接失敗：',
                treeView: '對話樹',
                conversationManagement: '對話管理',
                newBtn: '新建',
                newConversation: '新對話',
                oldConversation: '舊對話'
            },
            'en': {
                pageTitle: 'VibeChat(α) | Multi-branch LLM WebChat',
                exportBtn: 'Export',
                importBtn: 'Import',
                apiSettings: 'API Settings',
                apiUrl: 'API URL',
                apiKey: 'API Key',
                apiKeyPlaceholder: 'Enter API Key',
                modelName: 'Model Name',
                modelNamePlaceholder: 'Enter Model Name',
                temperature: 'Temperature',
                testConnection: 'Test Connection',
                deleteNode: 'Delete Node',
                inputPlaceholder: 'Enter your question...',
                sendBtn: 'Send',
                selectedNode: 'Selected Node:',
                confirmDelete: 'Are you sure you want to delete this node and all its children?',
                confirmClear: 'Are you sure you want to clear the conversation? This will delete all nodes except the system prompt.',
                confirmClearAgain: 'Confirm again: This will permanently delete all conversation content, keeping only the system node.',
                clearedAlert: 'Conversation cleared, only system prompt remains.',
                enterQuestion: 'Please enter a question',
                selectNode: 'Please select a node first',
                setApi: 'Please set API URL and API Key',
                resendUserOnly: 'Can only resend on user nodes',
                apiSuccess: 'API connection successful!',
                apiUnexpected: 'API connection test completed, but response was unexpected.',
                importSuccess: 'Conversation imported successfully!',
                invalidFormat: 'Invalid conversation file format',
                importFailed: 'Import failed:',
                system: 'System',
                user: 'User',
                assistant: 'Assistant',
                assistantReply: 'Assistant Reply',
                reasoningProcess: '⇅ Reasoning Process',
                resendTooltip: 'Resend this message',
                copyTooltip: 'Copy content',
                copySuccess: 'Copied successfully',
                darkThemeTooltip: 'MoonShot',
                lightThemeTooltip: 'SunFlare',
                clearConversationTitle: 'Clear Conversation',
                systemPrompt: 'You are a helpful AI assistant.',
                testMessage: 'Please reply "Connection successful" to confirm API connection is normal.',
                cannotDeleteStart: 'Cannot delete start node',
                sending: 'Sending...',
                testing: 'Testing...',
                editFinalAnswer: 'Edit node final answer:',
                editNodeContent: 'Edit node content:',
                newConversation: 'New Conversation',
                renameConversation: 'Rename',
                deleteConversation: 'Delete',
                switchConversation: 'Switch Conversation',
                confirmDeleteConversation: 'Are you sure you want to delete this conversation? This action cannot be undone.',
                enterConversationTitle: 'Please enter conversation title',
                defaultConversationTitle: 'New Conversation',
                sendFailed: 'Send failed:',
                resendFailed: 'Resend failed:',
                apiFailed: 'API connection failed:',
                treeView: 'Tree View',
                conversationManagement: 'Conversation Management',
                newBtn: 'New',
                newConversation: 'New Conversation',
                oldConversation: 'Old Conversation'
            },
            'ja': {
                pageTitle: 'VibeChat(α) | マルチブランチ LLM ウェブチャット',
                exportBtn: 'エクスポート',
                importBtn: 'インポート',
                apiSettings: 'API 設定',
                apiUrl: 'API URL',
                apiKey: 'API キー',
                apiKeyPlaceholder: 'APIキーを入力',
                modelName: 'モデル名',
                modelNamePlaceholder: 'モデル名を入力',
                temperature: '温度',
                testConnection: '接続テスト',
                deleteNode: 'ノード削除',
                inputPlaceholder: '質問を入力してください...',
                sendBtn: '送信',
                selectedNode: '選択ノード:',
                confirmDelete: 'このノードとすべての子ノードを削除してもよろしいですか？',
                confirmClear: '会話をクリアしてもよろしいですか？システムプロンプトを除くすべてのノードが削除されます。',
                confirmClearAgain: 'もう一度確認：すべての会話内容が完全に削除され、システムノードのみが残ります。',
                clearedAlert: '会話がクリアされ、システムプロンプトのみが残りました。',
                enterQuestion: '質問を入力してください',
                selectNode: 'まずノードを選択してください',
                setApi: 'API URLとAPIキーを設定してください',
                resendUserOnly: 'ユーザーノードでのみ再送信できます',
                apiSuccess: 'API接続に成功しました！',
                apiUnexpected: 'API接続テストは完了しましたが、応答が予期せぬものでした。',
                importSuccess: '会話のインポートに成功しました！',
                invalidFormat: '無効な会話ファイル形式',
                importFailed: 'インポートに失敗しました：',
                system: 'System',
                user: 'User',
                assistant: 'Assistant',
                assistantReply: 'アシスタント返信',
                reasoningProcess: '⇅ 推論プロセス',
                resendTooltip: 'このメッセージを再送信',
                copyTooltip: '内容をコピー',
                copySuccess: 'コピー成功',
                darkThemeTooltip: 'MoonShot',
                lightThemeTooltip: 'SunFlare',
                clearConversationTitle: '会話をクリア',
                systemPrompt: 'あなたは役立つAIアシスタントです。',
                testMessage: 'API接続が正常であることを確認するために「接続成功」と返信してください。',
                cannotDeleteStart: '開始ノードを削除できません',
                sending: '送信中...',
                testing: 'テスト中...',
                editFinalAnswer: 'ノードの最終回答を編集:',
                editNodeContent: 'ノードの内容を編集:',
                newConversation: '新規会話',
                renameConversation: '名前変更',
                deleteConversation: '削除',
                switchConversation: '会話切替',
                confirmDeleteConversation: 'この会話を削除してもよろしいですか？この操作は元に戻せません。',
                enterConversationTitle: '会話タイトルを入力してください',
                defaultConversationTitle: '新規会話',
                sendFailed: '送信失敗：',
                resendFailed: '再送信失敗：',
                apiFailed: 'API接続失敗：',
                treeView: '会話ツリー',
                conversationManagement: '会話管理',
                newBtn: '新規',
                newConversation: '新規会話',
                oldConversation: '旧会話'
            }
        };

        let currentLanguage = 'zh-CN';

        document.addEventListener('DOMContentLoaded', function() {
            initLanguage();
            initTheme();
            loadStateFromLocalStorage();
            
            if (!state.currentConversationId || !state.conversations[state.currentConversationId]) {
                createNewConversation();
            }
            
            setupEventListeners();
            setupMobileEvents();
            setupTabs();
            initMobileDrawer();
            renderAll();
            
            const container = document.getElementById('canvasContainer');
            if (getCurrentConversation().selectedNodeId) {
                scrollToNode(getCurrentConversation().selectedNodeId);
            } else {
                container.scrollTo(2500 - container.clientWidth / 2, 0);
            }
            
            window.addEventListener('beforeunload', saveStateToLocalStorage);
            window.addEventListener('resize', handleResize);
        });
        
        function getCurrentConversation() {
            return state.conversations[state.currentConversationId];
        }
        
        function initLanguage() {
            const browserLang = navigator.language || navigator.userLanguage;
            const lang = browserLang.split('-')[0];
            
            if (lang === 'zh') {
                currentLanguage = browserLang.includes('TW') || browserLang.includes('HK') ? 'zh-TW' : 'zh-CN';
            } else if (lang === 'ja') {
                currentLanguage = 'ja';
            } else {
                currentLanguage = 'en';
            }
            
            document.title = i18n('pageTitle');
            applyLanguage();
        }
        
        function applyLanguage() {
            document.querySelectorAll('[data-i18n]').forEach(element => {
                const key = element.getAttribute('data-i18n');
                if (i18nResources[currentLanguage][key]) {
                    element.textContent = i18nResources[currentLanguage][key];
                }
            });
            
            document.querySelectorAll('[data-i18n-placeholder]').forEach(element => {
                const key = element.getAttribute('data-i18n-placeholder');
                if (i18nResources[currentLanguage][key]) {
                    element.placeholder = i18nResources[currentLanguage][key];
                }
            });
        }
        
        function i18n(key) {
            return i18nResources[currentLanguage][key] || key;
        }
        
        function initTheme() {
            const prefersDark = window.matchMedia('(prefers-color-scheme: dark)').matches;
            const savedTheme = localStorage.getItem('vibechat-theme') || (prefersDark ? 'dark' : 'cupcake');
            document.documentElement.setAttribute('data-theme', savedTheme);
            updateThemeToggle(savedTheme);
        }
        
        function updateThemeToggle(theme) {
            const isDark = theme === 'dark';
            elements.themeToggle.innerHTML = isDark 
                ? `<svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 3v1m0 16v1m9-9h-1M4 12H3m15.364 6.364l-.707-.707M6.343 6.343l-.707-.707m12.728 0l-.707.707M6.343 17.657l-.707.707M16 12a4 4 0 11-8 0 4 4 0 018 0z" /></svg>`
                : `<svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M20.354 15.354A9 9 0 018.646 3.646 9.003 9.003 0 0012 21a9.003 9.003 0 008.354-5.646z" /></svg>`;
            updateThemeTooltip();
        }
        
        function updateThemeTooltip() {
            const currentTheme = document.documentElement.getAttribute('data-theme');
            elements.themeToggle.title = currentTheme === 'dark' ? i18n('lightThemeTooltip') : i18n('darkThemeTooltip');
        }
        
        function toggleTheme() {
            const currentTheme = document.documentElement.getAttribute('data-theme');
            const newTheme = currentTheme === 'dark' ? 'cupcake' : 'dark';
            
            document.documentElement.setAttribute('data-theme', newTheme);
            localStorage.setItem('vibechat-theme', newTheme);
            updateThemeToggle(newTheme);
        }
        
        function setupMobileEvents() {
            elements.mobileMenuBtn.addEventListener('click', toggleSidebar);
            elements.sidebarOverlay.addEventListener('click', closeSidebar);
            
            elements.treeView.addEventListener('click', function(e) {
                if (e.target.closest('.tree-node')) {
                    setTimeout(closeSidebar, 300);
                }
            });
        }
        
        function initMobileDrawer() {
            if (state.isMobile) {
                elements.sidebar.classList.add('hidden');
            } else {
                elements.sidebar.classList.remove('hidden');
            }
        }
        
        function toggleSidebar() {
            if (state.isMobile) {
                if (elements.sidebar.classList.contains('hidden')) {
                    elements.sidebar.classList.remove('hidden');
                    elements.sidebarOverlay.classList.add('active');
                } else {
                    closeSidebar();
                }
            }
        }
        
        function closeSidebar() {
            if (state.isMobile) {
                elements.sidebar.classList.add('hidden');
                elements.sidebarOverlay.classList.remove('active');
            }
        }
        
        function handleResize() {
            const wasMobile = state.isMobile;
            state.isMobile = window.innerWidth <= 1024;
            
            if (state.isMobile !== wasMobile) {
                if (!state.isMobile) {
                    elements.sidebar.classList.remove('hidden');
                    elements.sidebarOverlay.classList.remove('active');
                } else {
                    elements.sidebar.classList.add('hidden');
                }
            }
        }
        
        function setupTabs() {
            elements.treeviewTab.addEventListener('click', () => {
                elements.treeviewTab.classList.add('tab-active');
                elements.conversationsTab.classList.remove('tab-active');
                elements.treeviewContent.classList.remove('hidden');
                elements.conversationsContent.classList.add('hidden');
            });
            
            elements.conversationsTab.addEventListener('click', () => {
                elements.conversationsTab.classList.add('tab-active');
                elements.treeviewTab.classList.remove('tab-active');
                elements.conversationsContent.classList.remove('hidden');
                elements.treeviewContent.classList.add('hidden');
            });
        }
        
        function setupEventListeners() {
            elements.deleteNodeBtn.addEventListener('click', deleteNode);
            elements.clearConversationBtn.addEventListener('click', clearConversation);
            document.getElementById('exportBtn').addEventListener('click', exportConversation);
            document.getElementById('importBtn').addEventListener('click', () => document.getElementById('importFile').click());
            document.getElementById('importFile').addEventListener('change', importConversation);
            document.getElementById('zoomInBtn').addEventListener('click', () => adjustZoom(0.1));
            document.getElementById('zoomOutBtn').addEventListener('click', () => adjustZoom(-0.1));
            document.getElementById('resetZoomBtn').addEventListener('click', resetZoom);
            elements.sendBtn.addEventListener('click', sendMessage);
            elements.userInput.addEventListener('keypress', e => e.key === 'Enter' && sendMessage());
            document.getElementById('testApiBtn').addEventListener('click', testApiConnection);
            elements.themeToggle.addEventListener('click', toggleTheme);
            elements.newConversationBtn.addEventListener('click', createNewConversation);
            
            elements.canvas.addEventListener('click', handleNodeClick);
        }
        
        function handleNodeClick(e) {
            const nodeElement = e.target.closest('.node');
            if (!nodeElement) return;
            
            const nodeId = nodeElement.id;
            
            if (e.target.classList.contains('reasoning-toggle')) {
                toggleReasoning(nodeId);
                return;
            }
            
            if (e.target.classList.contains('resend-btn')) {
                resendMessage(nodeId);
                return;
            }
            
            if (e.target.classList.contains('copy-btn')) {
                copyNodeContent(nodeId);
                return;
            }
            
            if (e.target.classList.contains('node-content') || 
                e.target.classList.contains('reasoning-content') ||
                e.target.classList.contains('final-answer')) {
                editNodeContent(nodeId);
            } else {
                selectNode(nodeId);
            }
        }
        
        function createNewConversation() {
            const conversationId = 'conversation_' + Date.now();
            const now = new Date();
            const timeString = `${now.getFullYear()}${(now.getMonth()+1).toString().padStart(2, '0')}${now.getDate().toString().padStart(2, '0')}_${now.getHours().toString().padStart(2, '0')}${now.getMinutes().toString().padStart(2, '0')}`;
            const title = `${i18n('newConversation')}_${timeString}`;
            
            state.conversations[conversationId] = {
                title,
                nodes: {},
                startNode: null,
                selectedNodeId: null,
                zoomLevel: 1,
                treeCollapsedNodes: new Set()
            };
            
            state.currentConversationId = conversationId;
            
            const initialX = (5000 - CONSTANTS.NODE_WIDTH) / 2;
            createNode("system", i18n('systemPrompt'), initialX, 200, true);
            
            renderConversationsList();
            renderAll();
            saveStateToLocalStorage();
        }
        
        function switchConversation(conversationId) {
            if (state.conversations[conversationId]) {
                state.currentConversationId = conversationId;
                renderConversationsList();
                renderAll();
                saveStateToLocalStorage();
            }
        }
        
        function renameConversation(conversationId) {
            const conversation = state.conversations[conversationId];
            if (!conversation) return;
            
            const newTitle = prompt(i18n('enterConversationTitle'), conversation.title);
            if (newTitle && newTitle.trim() !== '') {
                conversation.title = newTitle.trim();
                renderConversationsList();
                saveStateToLocalStorage();
            }
        }
        
        function deleteConversation(conversationId) {
            if (Object.keys(state.conversations).length <= 1) {
                alert('不能删除最后一个对话');
                return;
            }
            
            if (!confirm(i18n('confirmDeleteConversation'))) return;
            
            delete state.conversations[conversationId];
            
            if (state.currentConversationId === conversationId) {
                const remainingIds = Object.keys(state.conversations);
                if (remainingIds.length > 0) {
                    state.currentConversationId = remainingIds[0];
                } else {
                    createNewConversation();
                }
            }
            
            renderConversationsList();
            renderAll();
            saveStateToLocalStorage();
        }
        
        function renderConversationsList() {
            const conversationsList = elements.conversationsList;
            conversationsList.innerHTML = '';
            
            Object.keys(state.conversations).forEach(conversationId => {
                const conversation = state.conversations[conversationId];
                
                const conversationItem = document.createElement('div');
                conversationItem.className = `conversation-item ${conversationId === state.currentConversationId ? 'active' : ''}`;
                if (conversationId === state.currentConversationId) {
                    conversationItem.style.backgroundColor = 'oklch(var(--p) / 0.2)';
                }
                
                const titleElement = document.createElement('div');
                titleElement.className = 'conversation-title';
                titleElement.textContent = conversation.title;
                titleElement.addEventListener('click', () => switchConversation(conversationId));
                
                const actionsElement = document.createElement('div');
                actionsElement.className = 'conversation-actions';
                
                const renameBtn = document.createElement('button');
                renameBtn.className = 'btn btn-xs btn-ghost btn-sm p-1';
                renameBtn.innerHTML = '<svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M11 5H6a2 2 0 00-2 2v11a2 2 0 002 2h11a2 2 0 002-2v-5m-1.414-9.414a2 2 0 112.828 2.828L11.828 15H9v-2.828l8.586-8.586z" /></svg>';
                renameBtn.title = i18n('renameConversation');
                renameBtn.addEventListener('click', (e) => {
                    e.stopPropagation();
                    renameConversation(conversationId);
                });
                
                const deleteBtn = document.createElement('button');
                deleteBtn.className = 'btn btn-xs btn-ghost text-error btn-sm p-1';
                deleteBtn.innerHTML = '<svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 7l-.867 12.142A2 2 0 0116.138 21H7.862a2 2 0 01-1.995-1.858L5 7m5 4v6m4-6v6m1-10V4a1 1 0 00-1-1h-4a1 1 0 00-1 1v3M4 7h16" /></svg>';
                deleteBtn.title = i18n('deleteConversation');
                deleteBtn.addEventListener('click', (e) => {
                    e.stopPropagation();
                    deleteConversation(conversationId);
                });
                
                actionsElement.appendChild(renameBtn);
                actionsElement.appendChild(deleteBtn);
                
                conversationItem.appendChild(titleElement);
                conversationItem.appendChild(actionsElement);
                
                conversationsList.appendChild(conversationItem);
            });
        }
        
        function createNode(role, content, x, y, isStart = false, reasoning = null) {
            const conversation = getCurrentConversation();
            const timestamp = Date.now();
            const randomStr = Math.random().toString(36).substr(2, 9);
            const id = `node_${role}_${timestamp}_${randomStr}`;
            
            conversation.nodes[id] = {
                id,
                role,
                content,
                reasoning,
                branches: [],
                position: { x, y }
            };
            
            if (isStart) {
                conversation.startNode = id;
                conversation.selectedNodeId = id;
            }
            
            return id;
        }
        
        function deleteNode() {
            const conversation = getCurrentConversation();
            if (!conversation.selectedNodeId || conversation.selectedNodeId === conversation.startNode) {
                alert(i18n('cannotDeleteStart'));
                return;
            }
            
            if (!confirm(i18n('confirmDelete'))) return;
            
            deleteNodeAndChildren(conversation.selectedNodeId);
            conversation.selectedNodeId = null;
            renderAll();
            saveStateToLocalStorage();
        }
        
        function deleteNodeAndChildren(nodeId) {
            const conversation = getCurrentConversation();
            if (!conversation.nodes[nodeId]) return;
            
            conversation.nodes[nodeId].branches.forEach(branch => {
                deleteNodeAndChildren(branch.nextNodeId);
            });
            
            Object.values(conversation.nodes).forEach(node => {
                node.branches = node.branches.filter(branch => branch.nextNodeId !== nodeId);
            });
            
            delete conversation.nodes[nodeId];
        }
        
        function clearConversation() {
            if (!confirm(i18n('confirmClear'))) return;
            if (!confirm(i18n('confirmClearAgain'))) return;
            
            const conversation = getCurrentConversation();
            const systemNode = conversation.nodes[conversation.startNode];
            if (!systemNode) return;
            
            conversation.nodes = {};
            conversation.nodes[conversation.startNode] = systemNode;
            systemNode.branches = [];
            conversation.selectedNodeId = conversation.startNode;
            
            renderAll();
            saveStateToLocalStorage();
            
            alert(i18n('clearedAlert'));
        }
        
        async function sendMessage() {
            const userInput = elements.userInput.value.trim();
            if (!userInput) {
                alert(i18n('enterQuestion'));
                return;
            }
            
            const conversation = getCurrentConversation();
            if (!conversation.selectedNodeId) {
                alert(i18n('selectNode'));
                return;
            }
            
            const apiUrl = document.getElementById('apiUrl').value.trim();
            const apiKey = document.getElementById('apiKey').value.trim();
            const modelName = document.getElementById('modelName').value.trim() || "deepseek-chat";
            const temperature = parseFloat(document.getElementById('temperature').value) || 1.0;
            
            if (!apiUrl || !apiKey) {
                alert(i18n('setApi'));
                return;
            }
            
            elements.sendBtn.disabled = true;
            elements.userInput.disabled = true;
            elements.sendBtn.textContent = i18n('sending');
            
            try {
                const contextMessages = getContextMessages(conversation.selectedNodeId);
                contextMessages.push({ role: 'user', content: userInput });
                
                const parentNode = conversation.nodes[conversation.selectedNodeId];
                const userNodePos = calculateNodePosition(parentNode, 'user');
                const newUserNodeId = createNode("user", userInput, userNodePos.x, userNodePos.y);
                
                const assistantNodePos = calculateNodePosition(conversation.nodes[newUserNodeId], 'assistant');
                const newAssistantNodeId = createNode("assistant", "", assistantNodePos.x, assistantNodePos.y);
                
                parentNode.branches.push({
                    id: 'branch_' + Date.now(),
                    nextNodeId: newUserNodeId
                });
                
                conversation.nodes[newUserNodeId].branches.push({
                    id: 'branch_' + Date.now(),
                    nextNodeId: newAssistantNodeId
                });
                
                conversation.selectedNodeId = newAssistantNodeId;
                elements.userInput.value = '';
                
                renderAll();
                scrollToNode(newAssistantNodeId);
                
                await callDeepseekAPIStream(apiUrl, apiKey, modelName, temperature, contextMessages, newAssistantNodeId);
                
            } catch (error) {
                console.error('Failed to send message:', error);
                alert(i18n('sendFailed') + error.message);
            } finally {
                elements.sendBtn.disabled = false;
                elements.userInput.disabled = false;
                elements.sendBtn.textContent = i18n('sendBtn');
                saveStateToLocalStorage();
            }
        }
        
        async function testApiConnection() {
            const apiUrl = document.getElementById('apiUrl').value.trim();
            const apiKey = document.getElementById('apiKey').value.trim();
            const modelName = document.getElementById('modelName').value.trim() || "deepseek-chat";
            const temperature = parseFloat(document.getElementById('temperature').value) || 1.0;
            
            if (!apiUrl || !apiKey) {
                alert(i18n('setApi'));
                return;
            }
            
            const testBtn = document.getElementById('testApiBtn');
            testBtn.disabled = true;
            testBtn.textContent = i18n('testing');
            
            try {
                const response = await fetch(apiUrl, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'Authorization': `Bearer ${apiKey}`
                    },
                    body: JSON.stringify({
                        model: modelName,
                        messages: [
                            { role: 'system', content: i18n('systemPrompt') },
                            { role: 'user', content: i18n('testMessage') }
                        ],
                        stream: false,
                        temperature: temperature
                    })
                });
                
                if (!response.ok) {
                    throw new Error(`API request failed: ${response.status} ${response.statusText}`);
                }
                
                const data = await response.json();
                
                if (data.choices?.[0]?.message?.content) {
                    alert(i18n('apiSuccess'));
                } else {
                    alert(i18n('apiUnexpected'));
                }
            } catch (error) {
                alert(i18n('apiFailed') + error.message);
            } finally {
                testBtn.disabled = false;
                testBtn.textContent = i18n('testConnection');
            }
        }
        
        async function resendMessage(userNodeId) {
            const conversation = getCurrentConversation();
            const userNode = conversation.nodes[userNodeId];
            if (!userNode || userNode.role !== 'user') {
                alert(i18n('resendUserOnly'));
                return;
            }
            
            const apiUrl = document.getElementById('apiUrl').value.trim();
            const apiKey = document.getElementById('apiKey').value.trim();
            const modelName = document.getElementById('modelName').value.trim() || "deepseek-chat";
            const temperature = parseFloat(document.getElementById('temperature').value) || 1.0;
            
            if (!apiUrl || !apiKey) {
                alert(i18n('setApi'));
                return;
            }
            
            const assistantNodePos = calculateNodePosition(userNode, 'assistant');
            const newAssistantNodeId = createNode("assistant", "", assistantNodePos.x, assistantNodePos.y);
            
            userNode.branches.push({
                id: 'branch_' + Date.now(),
                nextNodeId: newAssistantNodeId
            });
            
            conversation.selectedNodeId = newAssistantNodeId;
            
            renderAll();
            scrollToNode(newAssistantNodeId);
            
            const contextMessages = getContextMessages(userNodeId);
            
            try {
                await callDeepseekAPIStream(apiUrl, apiKey, modelName, temperature, contextMessages, newAssistantNodeId);
                saveStateToLocalStorage();
            } catch (error) {
                console.error('Failed to resend message:', error);
                alert(i18n('resendFailed') + error.message);
            }
        }
        
        async function callDeepseekAPIStream(apiUrl, apiKey, modelName, temperature, messages, assistantNodeId) {
            const conversation = getCurrentConversation();
            const assistantNode = conversation.nodes[assistantNodeId];
            
            assistantNode.content = '';
            assistantNode.reasoning = null;
            
            assistantNode.content = '<span class="typing-indicator"></span><span class="typing-indicator"></span><span class="typing-indicator"></span>';
            renderNodes();
            
            try {
                const response = await fetch(apiUrl, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'Authorization': `Bearer ${apiKey}`
                    },
                    body: JSON.stringify({
                        model: modelName,
                        messages,
                        stream: true,
                        temperature: temperature
                    })
                });
                
                if (!response.ok) {
                    throw new Error(`API request failed: ${response.status} ${response.statusText}`);
                }
                
                const reader = response.body.getReader();
                const decoder = new TextDecoder();
                let assistantContent = '';
                let reasoningContent = '';
                let isReasonerModel = false;
                
                while (true) {
                    const { done, value } = await reader.read();
                    if (done) break;
                    
                    const chunk = decoder.decode(value);
                    const lines = chunk.split('\n');
                    
                    for (const line of lines) {
                        if (line.startsWith('data: ') && line !== 'data: [DONE]') {
                            try {
                                const data = JSON.parse(line.slice(6));
                                
                                if (data.choices?.[0]?.delta?.reasoning_content !== undefined) {
                                    isReasonerModel = true;
                                    reasoningContent += data.choices[0].delta.reasoning_content || '';
                                    assistantNode.reasoning = reasoningContent;
                                }
                                
                                if (data.choices?.[0]?.delta?.content) {
                                    assistantContent += data.choices[0].delta.content;
                                    assistantNode.content = assistantContent;
                                }
                                
                                renderNodes();
                            } catch (e) {
                            }
                        }
                    }
                }
                
                if (isReasonerModel) {
                    assistantNode.reasoning = reasoningContent;
                    assistantNode.content = assistantContent;
                } else {
                    assistantNode.content = assistantContent;
                }
                
                renderAll();
                
            } catch (error) {
                console.error('Stream response error:', error);
                assistantNode.content = 'Error: ' + error.message;
                renderAll();
            }
        }
        
        function renderAll() {
            renderNodes();
            renderConnections();
            renderTreeView();
            renderConversationsList();
            updateUI();
            updateContextInfo();
        }
        
        function renderNodes() {
            const conversation = getCurrentConversation();
            const canvas = elements.canvas;
            const existingNodes = canvas.querySelectorAll('.node');
            const existingNodeIds = new Set(Array.from(existingNodes).map(node => node.id));
            const currentNodeIds = new Set(Object.keys(conversation.nodes));
            
            existingNodes.forEach(node => {
                if (!currentNodeIds.has(node.id)) {
                    node.remove();
                }
            });
            
            Object.values(conversation.nodes).forEach(node => {
                let nodeElement = document.getElementById(node.id);
                
                if (!nodeElement) {
                    nodeElement = createNodeElement(node);
                    canvas.appendChild(nodeElement);
                    makeDraggable(nodeElement, node);
                } else {
                    updateNodeElement(nodeElement, node);
                }
            });
            
            updateSelection();
        }
        
        function createNodeElement(node) {
            const element = document.createElement('div');
            element.className = `card bg-base-200 shadow-xl node ${node.role}`;
            element.id = node.id;
            element.style.left = node.position.x + 'px';
            element.style.top = node.position.y + 'px';
            
            const roleColors = {
                system: 'badge-success',
                user: 'badge-primary',
                assistant: 'badge-secondary'
            };
            
            let buttonsHTML = '';
            if (node.role === 'user') {
                buttonsHTML += `<button class="node-btn resend-btn" data-node-id="${node.id}" title="${i18n('resendTooltip')}">↻</button>`;
            }
            buttonsHTML += `<button class="node-btn copy-btn" data-node-id="${node.id}" title="${i18n('copyTooltip')}">⎘</button>`;
            
            let contentHTML = '';
            
            if (node.reasoning !== undefined && node.reasoning !== null) {
                contentHTML += `
                    <div class="reasoning-toggle" data-node-id="${node.id}">${i18n('reasoningProcess')}</div>
                    <div class="reasoning-content reasoning-collapsed" data-node-id="${node.id}">${node.reasoning.includes('typing-indicator') ? node.reasoning : escapeHtml(node.reasoning)}</div>
                    <div class="final-answer" style="margin-top: 8px;">${node.content.includes('typing-indicator') ? node.content : marked.parse(node.content)}</div>
                `;
            } else {
                contentHTML = node.content.includes('typing-indicator') ? node.content : marked.parse(node.content);
            }
            
            element.innerHTML = `
                ${buttonsHTML}
                <div class="card-body p-4" style="height: ${CONSTANTS.NODE_HEIGHT[node.role]}px;">
                    <div class="badge text-white ${roleColors[node.role]} mb-1" style="font-size: 10px; font-weight: bold;">${i18n(node.role)}</div>
                    <div class="node-content">${contentHTML}</div>
                </div>
            `;
            
            return element;
        }
        
        function escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }
        
        function updateNodeElement(element, node) {
            const cardBody = element.querySelector('.card-body');
            if (!cardBody) return;
            
            const content = cardBody.querySelector('.node-content');
            const hasTyping = node.content.includes('typing-indicator');
            const hasReasoning = node.reasoning !== undefined && node.reasoning !== null;
            
            if (hasReasoning) {
                let reasoningToggle = content.querySelector('.reasoning-toggle');
                let reasoningContentDiv = content.querySelector('.reasoning-content');
                let finalAnswer = content.querySelector('.final-answer');
                
                if (!reasoningToggle || !reasoningContentDiv || !finalAnswer) {
                    let buttonsHTML = '';
                    if (node.role === 'user') {
                        buttonsHTML += `<button class="node-btn resend-btn" data-node-id="${node.id}" title="${i18n('resendTooltip')}">↻</button>`;
                    }
                    buttonsHTML += `<button class="node-btn copy-btn" data-node-id="${node.id}" title="${i18n('copyTooltip')}">⎘</button>`;
                    
                    const roleColors = {
                        system: 'badge-success',
                        user: 'badge-primary',
                        assistant: 'badge-secondary'
                    };
                    element.innerHTML = `
                        ${buttonsHTML}
                        <div class="card-body p-4" style="height: ${CONSTANTS.NODE_HEIGHT[node.role]}px;">
                            <div class="badge text-white ${roleColors[node.role]} mb-1" style="font-size: 10px; font-weight: bold;">${i18n(node.role)}</div>
                            <div class="node-content">
                                <div class="reasoning-toggle" data-node-id="${node.id}">${i18n('reasoningProcess')}</div>
                                <div class="reasoning-content reasoning-collapsed" data-node-id="${node.id}"></div>
                                <div class="final-answer" style="margin-top: 8px;"></div>
                            </div>
                        </div>
                    `;
                }
                
                reasoningToggle = content.querySelector('.reasoning-toggle');
                reasoningContentDiv = content.querySelector('.reasoning-content');
                finalAnswer = content.querySelector('.final-answer');
                
                if (reasoningToggle) {
                    reasoningToggle.textContent = i18n('reasoningProcess');
                }
                
                if (reasoningContentDiv) {
                    reasoningContentDiv.innerHTML = node.reasoning.includes('typing-indicator') ? node.reasoning : escapeHtml(node.reasoning);
                }
                
                if (finalAnswer) {
                    finalAnswer.innerHTML = hasTyping ? node.content : marked.parse(node.content);
                }
            } else {
                content.innerHTML = hasTyping ? node.content : marked.parse(node.content);
            }
            
            element.style.left = node.position.x + 'px';
            element.style.top = node.position.y + 'px';
        }
        
        function renderConnections() {
            const conversation = getCurrentConversation();
            const svg = elements.connections;
            svg.innerHTML = '';
            
            Object.values(conversation.nodes).forEach(node => {
                node.branches.forEach(branch => {
                    const targetNode = conversation.nodes[branch.nextNodeId];
                    if (targetNode) drawConnection(svg, node, targetNode);
                });
            });
        }
        
        function drawConnection(svg, fromNode, toNode) {
            const conversation = getCurrentConversation();
            const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
            
            const fromY = fromNode.position.y + CONSTANTS.NODE_HEIGHT[fromNode.role];
            const fromX = fromNode.position.x + CONSTANTS.NODE_WIDTH / 2;
            const toX = toNode.position.x + CONSTANTS.NODE_WIDTH / 2;
            const toY = toNode.position.y;
            
            const pathData = `M ${fromX} ${fromY} C ${fromX} ${fromY + 125}, ${toX} ${toY - 125}, ${toX} ${toY}`;
            path.setAttribute('d', pathData);
            
            const pathToSelected = getPathToNode(conversation.startNode, conversation.selectedNodeId);
            const inPath = pathToSelected.includes(fromNode.id) && pathToSelected.includes(toNode.id);
            
            const currentTheme = document.documentElement.getAttribute('data-theme');
            const isdark = currentTheme === 'dark';
            
            path.setAttribute('stroke', inPath ? (isdark ? '#818cf8' : '#65c3c8') : (isdark ? '#6b7280' : '#6c757d'));
            path.setAttribute('stroke-width', inPath ? '2' : '1');
            path.setAttribute('fill', 'none');
            path.setAttribute('stroke-dasharray', inPath ? 'none' : '5,5');
            
            svg.appendChild(path);
        }
        
        function renderTreeView() {
            const conversation = getCurrentConversation();
            const treeView = elements.treeView;
            treeView.innerHTML = '';
            
            if (conversation.startNode) {
                const treeNode = createTreeNode(conversation.startNode);
                treeView.appendChild(treeNode);
            }
        }
        
        function createTreeNode(nodeId) {
            const conversation = getCurrentConversation();
            const node = conversation.nodes[nodeId];
            if (!node) return null;
            
            const li = document.createElement('li');
            
            const treeNode = document.createElement('div');
            treeNode.className = 'tree-node flex items-center gap-1';
            if (node.branches.length > 0) {
                treeNode.classList.add('has-children');
            }
            
            if (node.branches.length > 0) {
                const toggle = document.createElement('span');
                toggle.className = 'tree-toggle text-base-content/50';
                toggle.innerHTML = conversation.treeCollapsedNodes.has(nodeId) ? '▶' : '▼';
                toggle.dataset.nodeId = nodeId;
                toggle.addEventListener('click', function(e) {
                    e.stopPropagation();
                    toggleTreeNode(nodeId);
                });
                treeNode.appendChild(toggle);
            }

            const roleBadge = document.createElement('span');
            const roleColors = { system: 'badge-success', user: 'badge-primary', assistant: 'badge-secondary' };
            roleBadge.className = `badge text-white badge-xs ${roleColors[node.role]}`;
            roleBadge.textContent = node.role.substring(0, 1).toUpperCase();
            
            const content = document.createTextNode(
                node.content.length > 30 ? node.content.substring(0, 30) + '...' : node.content
            );
            
            treeNode.appendChild(roleBadge);
            treeNode.appendChild(content);
            treeNode.dataset.nodeId = nodeId;
            
            treeNode.addEventListener('click', (e) => {
                e.stopPropagation();
                selectNode(nodeId);
                scrollToNode(nodeId);
            });
            
            li.appendChild(treeNode);
            
            if (node.branches.length > 0) {
                const childList = document.createElement('ul');
                childList.className = 'tree-children';
                if (conversation.treeCollapsedNodes.has(nodeId)) {
                    childList.classList.add('collapsed');
                }
                
                node.branches.forEach(branch => {
                    const childNode = createTreeNode(branch.nextNodeId);
                    if (childNode) childList.appendChild(childNode);
                });
                
                li.appendChild(childList);
            }
            
            return li;
        }
        
        function toggleTreeNode(nodeId) {
            const conversation = getCurrentConversation();
            if (conversation.treeCollapsedNodes.has(nodeId)) {
                conversation.treeCollapsedNodes.delete(nodeId);
            } else {
                conversation.treeCollapsedNodes.add(nodeId);
            }
            renderTreeView();
        }
        
        function calculateNodePosition(parentNode, nodeType) {
            const conversation = getCurrentConversation();
            const parentPos = parentNode.position;
            
            const children = Object.values(conversation.nodes).filter(node => 
                parentNode.branches.some(branch => branch.nextNodeId === node.id)
            );
            
            let newY = parentPos.y + CONSTANTS.VERTICAL_SPACING;
            let newX = parentPos.x;
            
            if (children.length > 0) {
                const avgX = children.reduce((sum, node) => sum + node.position.x, 0) / children.length;
                newX = avgX + (children.length * CONSTANTS.HORIZONTAL_SPACING);
                
                let attempts = 0;
                while (isOverlapping(newX, newY, nodeType) && attempts < 10) {
                    newX += CONSTANTS.HORIZONTAL_SPACING;
                    attempts++;
                }
            }
            
            return { x: newX, y: newY };
        }
        
        function isOverlapping(x, y, nodeType) {
            const conversation = getCurrentConversation();
            const nodeWidth = CONSTANTS.NODE_WIDTH + 20;
            const nodeHeight = CONSTANTS.NODE_HEIGHT[nodeType];
            
            return Object.values(conversation.nodes).some(node => {
                const existingNodeHeight = CONSTANTS.NODE_HEIGHT[node.role];
                
                return (
                    x < node.position.x + nodeWidth && 
                    x + nodeWidth > node.position.x && 
                    y < node.position.y + existingNodeHeight && 
                    y + nodeHeight > node.position.y
                );
            });
        }
        
        function getContextMessages(nodeId) {
            const conversation = getCurrentConversation();
            const path = getPathToNode(conversation.startNode, nodeId);
            return path.map(id => {
                const node = conversation.nodes[id];
                return { role: node.role, content: node.content };
            });
        }
        
        function getPathToNode(startNodeId, targetNodeId, path = []) {
            const conversation = getCurrentConversation();
            if (!startNodeId) return [];
            
            path.push(startNodeId);
            
            if (startNodeId === targetNodeId) return path;
            
            const node = conversation.nodes[startNodeId];
            for (let branch of node.branches) {
                const result = getPathToNode(branch.nextNodeId, targetNodeId, [...path]);
                if (result.length > 0) return result;
            }
            
            return [];
        }
        
        function selectNode(nodeId) {
            const conversation = getCurrentConversation();
            conversation.selectedNodeId = nodeId;
            updateSelection();
            updateUI();
            updateContextInfo();
            renderConnections();
            saveStateToLocalStorage();
        }
        
        function updateSelection() {
            const conversation = getCurrentConversation();
            const path = getPathToNode(conversation.startNode, conversation.selectedNodeId);
            
            Object.values(conversation.nodes).forEach(node => {
                const element = document.getElementById(node.id);
                if (!element) return;
                
                const inPath = path.includes(node.id);
                
                if (node.id === conversation.selectedNodeId) {
                    element.classList.add('selected');
                    element.classList.remove('muted');
                } else if (inPath) {
                    element.classList.remove('selected');
                    element.classList.remove('muted');
                } else {
                    element.classList.remove('selected');
                    element.classList.add('muted');
                }
            });
            
            document.querySelectorAll('.tree-node').forEach(treeNode => {
                treeNode.classList.toggle('selected', treeNode.dataset.nodeId === conversation.selectedNodeId);
                if (treeNode.dataset.nodeId === conversation.selectedNodeId) {
                    treeNode.style.backgroundColor = 'oklch(var(--p) / 0.2)';
                } else {
                    treeNode.style.backgroundColor = '';
                }
            });
        }
        
        function updateUI() {
            const conversation = getCurrentConversation();
            const hasSelection = conversation.selectedNodeId !== null;
            elements.deleteNodeBtn.disabled = !hasSelection;
            elements.sendBtn.disabled = !hasSelection;
        }
        
        function updateContextInfo() {
            const conversation = getCurrentConversation();
            if (!conversation.selectedNodeId) {
                elements.contextInfo.textContent = '0';
                return;
            }
            
            const path = getPathToNode(conversation.startNode, conversation.selectedNodeId);
            elements.contextInfo.textContent = path.length;
        }
        
        function editNodeContent(nodeId) {
            const conversation = getCurrentConversation();
            const node = conversation.nodes[nodeId];
            
            if (node.reasoning !== undefined && node.reasoning !== null) {
                const newContent = prompt(i18n('editFinalAnswer'), node.content);
                if (newContent !== null) {
                    node.content = newContent;
                    renderAll();
                    saveStateToLocalStorage();
                }
            } else {
                const newContent = prompt(i18n('editNodeContent'), node.content);
                if (newContent !== null) {
                    node.content = newContent;
                    renderAll();
                    saveStateToLocalStorage();
                }
            }
        }
        
        function toggleReasoning(nodeId) {
            const nodeElement = document.getElementById(nodeId);
            if (!nodeElement) return;
            
            const reasoningContent = nodeElement.querySelector('.reasoning-content');
            if (!reasoningContent) return;
            
            reasoningContent.classList.toggle('reasoning-collapsed');
        }
        
        function copyNodeContent(nodeId) {
            const conversation = getCurrentConversation();
            const node = conversation.nodes[nodeId];
            if (!node) return;
            
            let textToCopy = node.content;
            
            const tempElement = document.createElement('div');
            tempElement.innerHTML = node.content;
            textToCopy = tempElement.textContent || tempElement.innerText || '';
            
            navigator.clipboard.writeText(textToCopy).then(() => {
                showCopySuccess(nodeId);
            }).catch(err => {
                console.error('Copy failed:', err);
                const textArea = document.createElement('textarea');
                textArea.value = textToCopy;
                document.body.appendChild(textArea);
                textArea.select();
                document.execCommand('copy');
                document.body.removeChild(textArea);
                showCopySuccess(nodeId);
            });
        }
        
        function showCopySuccess(nodeId) {
            const nodeElement = document.getElementById(nodeId);
            if (!nodeElement) return;
            
            let successElement = nodeElement.querySelector('.copy-success');
            if (!successElement) {
                successElement = document.createElement('div');
                successElement.className = 'copy-success';
                successElement.textContent = i18n('copySuccess');
                nodeElement.appendChild(successElement);
            }
            
            successElement.classList.add('show');
            
            setTimeout(() => {
                successElement.classList.remove('show');
            }, 2000);
        }
        
        function makeDraggable(element, node) {
            element.addEventListener('mousedown', startDrag);
            
            function startDrag(e) {
                if (e.target.classList.contains('node-content') || 
                    e.target.classList.contains('reasoning-content') ||
                    e.target.classList.contains('final-answer') ||
                    e.target.classList.contains('reasoning-toggle') ||
                    e.target.classList.contains('node-btn')) return;
                
                state.isDragging = true;
                state.dragStart.x = e.clientX;
                state.dragStart.y = e.clientY;
                const initialX = element.offsetLeft;
                const initialY = element.offsetTop;
                
                function drag(e) {
                    if (!state.isDragging) return;
                    
                    const dx = e.clientX - state.dragStart.x;
                    const dy = e.clientY - state.dragStart.y;
                    
                    const newX = initialX + dx;
                    const newY = initialY + dy;
                    
                    element.style.left = newX + 'px';
                    element.style.top = newY + 'px';
                    
                    node.position.x = newX;
                    node.position.y = newY;
                    
                    renderConnections();
                }
                
                function stopDrag() {
                    state.isDragging = false;
                    document.removeEventListener('mousemove', drag);
                    document.removeEventListener('mouseup', stopDrag);
                    saveStateToLocalStorage();
                }
                
                document.addEventListener('mousemove', drag);
                document.addEventListener('mouseup', stopDrag);
                
                e.preventDefault();
            }
        }
        
        function scrollToNode(nodeId) {
            const conversation = getCurrentConversation();
            const nodeElement = document.getElementById(nodeId);
            if (!nodeElement) return;
            
            const node = conversation.nodes[nodeId];
            const nodeX = node.position.x + CONSTANTS.NODE_WIDTH / 2;
            const nodeY = node.position.y + CONSTANTS.NODE_HEIGHT[node.role] / 2;
            const container = document.getElementById('canvasContainer');
            
            const scrollX = nodeX * conversation.zoomLevel - container.clientWidth / 2;
            const scrollY = nodeY * conversation.zoomLevel - container.clientHeight / 2;
            
            container.scrollTo(scrollX, scrollY);
        }
        
        function adjustZoom(delta) {
            const conversation = getCurrentConversation();
            conversation.zoomLevel = Math.max(0.3, Math.min(3, conversation.zoomLevel + delta));
            elements.canvas.style.transform = `scale(${conversation.zoomLevel})`;
            renderConnections();
        }
        
        function resetZoom() {
            const conversation = getCurrentConversation();
            conversation.zoomLevel = 1;
            elements.canvas.style.transform = 'scale(1)';
            renderConnections();
        }
        
        function saveStateToLocalStorage() {
            try {
                const conversationsToSave = {};
                Object.keys(state.conversations).forEach(conversationId => {
                    const conversation = state.conversations[conversationId];
                    conversationsToSave[conversationId] = {
                        ...conversation,
                        treeCollapsedNodes: Array.from(conversation.treeCollapsedNodes)
                    };
                });
                
                const stateToSave = {
                    conversations: conversationsToSave,
                    currentConversationId: state.currentConversationId,
                    apiSettings: {
                        apiUrl: document.getElementById('apiUrl').value,
                        apiKey: document.getElementById('apiKey').value,
                        modelName: document.getElementById('modelName').value,
                        temperature: document.getElementById('temperature').value
                    },
                    version: "2.0-daisyui"
                };
                
                localStorage.setItem('vibechat-state', JSON.stringify(stateToSave));
            } catch (error) {
                console.error('Failed to save to localStorage:', error);
            }
        }
        
        function loadStateFromLocalStorage() {
            try {
                const savedState = localStorage.getItem('vibechat-state');
                if (savedState) {
                    const parsedState = JSON.parse(savedState);
                    
                    if (parsedState.version === "2.0-daisyui" || parsedState.version === "2.0") {
                        if (parsedState.conversations) {
                            state.conversations = parsedState.conversations;
                            
                            Object.keys(state.conversations).forEach(conversationId => {
                                const conversation = state.conversations[conversationId];
                                if (conversation.treeCollapsedNodes && !(conversation.treeCollapsedNodes instanceof Set)) {
                                    if (Array.isArray(conversation.treeCollapsedNodes)) {
                                        conversation.treeCollapsedNodes = new Set(conversation.treeCollapsedNodes);
                                    } else {
                                        conversation.treeCollapsedNodes = new Set();
                                    }
                                } else if (!conversation.treeCollapsedNodes) {
                                    conversation.treeCollapsedNodes = new Set();
                                }
                                
                                if (!conversation.zoomLevel) {
                                    conversation.zoomLevel = 1;
                                }
                            });
                        }
                        
                        if (parsedState.currentConversationId) {
                            state.currentConversationId = parsedState.currentConversationId;
                        }
                    } else {
                        console.log("检测到旧版本数据，正在转换...");
                        convertOldState(parsedState);
                    }
                    
                    if (parsedState.apiSettings) {
                        document.getElementById('apiUrl').value = parsedState.apiSettings.apiUrl || 'https://api.deepseek.com/chat/completions';
                        document.getElementById('apiKey').value = parsedState.apiSettings.apiKey || '';
                        document.getElementById('modelName').value = parsedState.apiSettings.modelName || 'deepseek-chat';
                        document.getElementById('temperature').value = parsedState.apiSettings.temperature || '1.0';
                    }
                }
            } catch (error) {
                console.error('Failed to restore state from localStorage:', error);
            }
        }
        
        function convertOldState(oldState) {
            const conversationId = 'conversation_' + Date.now();
            const now = new Date();
            const timeString = `${now.getFullYear()}${(now.getMonth()+1).toString().padStart(2, '0')}${now.getDate().toString().padStart(2, '0')}_${now.getHours().toString().padStart(2, '0')}${now.getMinutes().toString().padStart(2, '0')}`;
            const title = `${i18n('oldConversation')}_${timeString}`;
            
            state.conversations[conversationId] = {
                title,
                nodes: {},
                startNode: null,
                selectedNodeId: null,
                zoomLevel: 1,
                treeCollapsedNodes: new Set()
            };
            
            const conversation = state.conversations[conversationId];
            
            if (oldState.conversation) {
                conversation.nodes = oldState.conversation.nodes || {};
                conversation.startNode = oldState.conversation.startNode || null;
                conversation.selectedNodeId = oldState.selectedNodeId || null;
                
                if (oldState.zoomLevel) {
                    conversation.zoomLevel = oldState.zoomLevel;
                }
                
                if (oldState.treeCollapsedNodes) {
                    if (oldState.treeCollapsedNodes instanceof Set) {
                        conversation.treeCollapsedNodes = oldState.treeCollapsedNodes;
                    } else if (Array.isArray(oldState.treeCollapsedNodes)) {
                        conversation.treeCollapsedNodes = new Set(oldState.treeCollapsedNodes);
                    } else if (typeof oldState.treeCollapsedNodes === 'object') {
                        conversation.treeCollapsedNodes = new Set(Object.keys(oldState.treeCollapsedNodes));
                    }
                }
            }
            
            state.currentConversationId = conversationId;
            
            saveStateToLocalStorage();
        }
        
        function exportConversation() {
            const conversation = getCurrentConversation();
            const now = new Date();
            const timestamp = `${now.getFullYear()}${(now.getMonth()+1).toString().padStart(2, '0')}${now.getDate().toString().padStart(2, '0')}_${now.getHours().toString().padStart(2, '0')}${now.getMinutes().toString().padStart(2, '0')}${now.getSeconds().toString().padStart(2, '0')}`;
            
            const exportData = {
                version: "2.0-daisyui",
                exportTime: now.toISOString(),
                title: conversation.title,
                nodes: {},
                startNode: conversation.startNode
            };
            
            Object.values(conversation.nodes).forEach(node => {
                exportData.nodes[node.id] = {
                    id: node.id,
                    role: node.role,
                    content: node.content,
                    reasoning: node.reasoning,
                    branches: node.branches.map(branch => ({
                        id: branch.id,
                        nextNodeId: branch.nextNodeId
                    })),
                    position: {
                        x: node.position.x,
                        y: node.position.y
                    }
                };
            });
            
            const dataStr = JSON.stringify(exportData, null, 2);
            const dataBlob = new Blob([dataStr], {type: 'application/json'});
            
            const link = document.createElement('a');
            link.href = URL.createObjectURL(dataBlob);
            link.download = `${conversation.title}_${timestamp}.json`;
            link.click();
        }
        
        function importConversation(event) {
            const file = event.target.files[0];
            if (!file) return;
            
            const reader = new FileReader();
            reader.onload = function(e) {
                try {
                    const importedData = JSON.parse(e.target.result);
                    
                    if (!importedData.nodes || !importedData.startNode) {
                        alert(i18n('invalidFormat'));
                        return;
                    }
                    
                    const conversationId = 'conversation_' + Date.now();
                    const title = importedData.title || `${i18n('newConversation')}_${new Date().toLocaleDateString()}`;
                    
                    state.conversations[conversationId] = {
                        title,
                        nodes: {},
                        startNode: importedData.startNode,
                        selectedNodeId: null,
                        zoomLevel: 1,
                        treeCollapsedNodes: new Set()
                    };
                    
                    const conversation = state.conversations[conversationId];
                    
                    Object.values(importedData.nodes).forEach(node => {
                        const branches = node.branches || [];
                        
                        const normalizedBranches = branches.map(branch => ({
                            id: branch.id || 'branch_' + Date.now() + '_' + Math.random().toString(36).substr(2, 5),
                            nextNodeId: branch.nextNodeId
                        }));
                        
                        const position = node.position || { x: 0, y: 0 };
                        
                        conversation.nodes[node.id] = {
                            id: node.id,
                            role: node.role || 'user',
                            content: node.content || '',
                            reasoning: node.reasoning || null,
                            branches: normalizedBranches,
                            position: position
                        };
                    });
                    
                    const needsAutoArrange = Object.values(conversation.nodes).some(node => 
                        node.position.x === 0 && node.position.y === 0
                    );
                    
                    if (needsAutoArrange) {
                        autoArrangeNodes(conversation);
                    }
                    
                    state.currentConversationId = conversationId;
                    renderConversationsList();
                    renderAll();
                    saveStateToLocalStorage();
                    
                    alert(i18n('importSuccess'));
                } catch (error) {
                    alert(i18n('importFailed') + error.message);
                    console.error('Import error:', error);
                }
                
                event.target.value = '';
            };
            reader.readAsText(file);
        }
        
        function autoArrangeNodes(conversation) {
            if (!conversation.startNode) return;
            
            const queue = [{nodeId: conversation.startNode, depth: 0}];
            const visited = new Set();
            const depthMap = {};
            
            while (queue.length > 0) {
                const {nodeId, depth} = queue.shift();
                
                if (visited.has(nodeId)) continue;
                visited.add(nodeId);
                
                if (!depthMap[depth]) depthMap[depth] = [];
                depthMap[depth].push(nodeId);
                
                const node = conversation.nodes[nodeId];
                node.branches.forEach(branch => {
                    queue.push({nodeId: branch.nextNodeId, depth: depth + 1});
                });
            }
            
            const maxDepth = Math.max(...Object.keys(depthMap).map(Number));
            
            for (let depth = 0; depth <= maxDepth; depth++) {
                const nodesAtDepth = depthMap[depth] || [];
                const count = nodesAtDepth.length;
                
                const startX = 2500 - (count * CONSTANTS.HORIZONTAL_SPACING) / 2;
                
                nodesAtDepth.forEach((nodeId, index) => {
                    conversation.nodes[nodeId].position = {
                        x: startX + index * CONSTANTS.HORIZONTAL_SPACING,
                        y: 200 + depth * CONSTANTS.VERTICAL_SPACING
                    };
                });
            }
        }
    </script>
</body>
</html>
