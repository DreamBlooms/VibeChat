<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>VibeChat(Œ±) | Â§öÂàÜÊîØ LLM WebChat</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Doto:wght@100..900&display=swap" rel="stylesheet">
    <link href="https://fastly.jsdelivr.net/npm/bootstrap@5.3.8/dist/css/bootstrap.min.css" rel="stylesheet">
    <script src="https://fastly.jsdelivr.net/npm/bootstrap@5.3.8/dist/js/bootstrap.bundle.min.js"></script>
    <script src="https://fastly.jsdelivr.net/npm/marked/marked.min.js"></script>
    
    <style>
        body {
            font-family: 'Microsoft Yahei UI', 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background-color: #f8f9fa;
            overflow: hidden;
            margin: 0;
            padding: 0;
        }
        
        .vibe-font { font-family: 'Doto', sans-serif; font-weight: 300; }
        .container-fluid { height: 100vh; padding: 0; }
        .sidebar { background-color: #343a40; color: white; height: 100vh; overflow-y: auto; }
        .editor-container { position: relative; height: 100vh; overflow: hidden; background-color: #e9ecef; display: flex; flex-direction: column; padding: 0 !important; }
        .story-canvas-container { position: relative; width: 100%; flex: 1; overflow: auto; }
        .story-canvas { position: relative; width: 5000px; height: 5000px; background-color: #e9ecef; background-image: linear-gradient(#dee2e6 1px, transparent 1px), linear-gradient(90deg, #dee2e6 1px, transparent 1px); background-size: 20px 20px; transform-origin: 0 0; transition: transform 0.1s ease; }
        .node { position: absolute; width: 450px; background-color: white; border-radius: 8px; box-shadow: 0 3px 10px rgba(0,0,0,0.1); padding: 15px; cursor: move; transition: all 0.2s; z-index: 10; padding: .5rem !important; }
        .node.selected { box-shadow: 0 0 0 2px #007bff, 0 5px 15px rgba(0,0,0,0.2); z-index: 20; }
        .node.muted { opacity: 0.4; background-color: #f8f9fa; }
        .node.system { border-left: 5px solid #28a745; height: 150px; }
        .node.user { border-left: 5px solid #007bff; height: 150px; }
        .node.assistant { border-left: 5px solid #6f42c1; height: 250px; }
        .node-content { font-size: 14px; margin-bottom: 0; border: 1px dashed #dee2e6; padding: 8px; border-radius: 4px; word-break: break-word; overflow-y: auto; height: calc(100% - 25px); }
        .connections { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; z-index: 5; }
        .tree-view { list-style-type: none; padding-left: 0; min-width: 200px; overflow-x: auto; }
        .tree-view ul { list-style-type: none; padding-left: 20px; }
        .tree-node { padding: 5px 10px; cursor: pointer; border-radius: 4px; margin-bottom: 2px; min-width: 200px; font-size: .875em; }
        .tree-node:hover { background-color: #495057; }
        .tree-node.selected { background-color: #007bff; }
        .zoom-controls, .toolbar { position: absolute; top: 20px; z-index: 100; }
        .zoom-controls { right: 20px; }
        .toolbar { left: 20px; }
        .chat-input-container { background-color: white; padding: 25px; border-top: 1px solid #dee2e6; z-index: 100; flex-shrink: 0; }
        .api-settings { padding: 4px 4px; }
        .role-indicator { font-size: 10px; font-weight: bold; padding: 2px 6px; border-radius: 10px; margin-bottom: 5px; display: inline-block; }
        .role-system { background-color: #28a745; color: white; }
        .role-user { background-color: #007bff; color: white; }
        .role-assistant { background-color: #6f42c1; color: white; }
        .typing-indicator { display: inline-block; width: 10px; height: 10px; background-color: #6c757d; border-radius: 50%; margin-right: 5px; animation: typing 1s infinite; }
        @keyframes typing { 0%, 100% { opacity: 0.3; } 50% { opacity: 1; } }
        .reasoning-content { background-color: #f8f9fa; border: 1px solid #e9ecef; border-radius: 4px; padding: 8px; margin-bottom: 8px; font-size: 13px; color: #6c757d; max-height: 120px; overflow-y: auto; }
        .reasoning-toggle { font-size: 12px; color: #6c757d; cursor: pointer; user-select: none; margin-bottom: 5px; display: inline-block; }
        .reasoning-toggle:hover { color: #495057; }
        .reasoning-collapsed { max-height: 55px; overflow: hidden; }
        .reasoning-collapsed::after { content: "..."; display: block; text-align: center; color: #adb5bd; }
        .resend-btn, .copy-btn { position: absolute; top: 5px; background: rgba(255, 255, 255, 0.9); border: 1px solid #dee2e6; border-radius: 4px; padding: 2px 6px; font-size: 10px; cursor: pointer; z-index: 15; opacity: 0; transition: opacity 0.2s; }
        .copy-btn { right: 5px; }
        .resend-btn { right: 30px; }
        .node:hover .resend-btn, .node:hover .copy-btn { opacity: 1; }
        .resend-btn:hover { background-color: #007bff; color: white; }
        .copy-btn:hover { background-color: #28a745; color: white; }
        .copy-success { position: absolute; top: 5px; left: 50%; transform: translateX(-50%); background-color: #0dcaf0; color: white; padding: 2px 6px; border-radius: 4px; font-size: 10px; z-index: 15; opacity: 0; transition: opacity 0.2s; }
        .copy-success.show { opacity: 1; }
        
        /* ÁßªÂä®Á´Ø‰ºòÂåñ */
        .mobile-sidebar-toggle {
            display: none;
            position: absolute;
            top: -3px;
            left: -3px;
            z-index: 1000;
            background: rgba(52, 58, 64, 0.9);
            border: none;
            color: white;
            border-radius: 4px;
            padding: 8px 12px;
            font-size: 14px;
        }
        
        .sidebar-backdrop {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.5);
            z-index: 999;
        }
        
        /* Á≤æÁÆÄÁöÑMarkdownÊ†∑Âºè */
        .node-content { font-size: 14px; line-height: 1.5; word-wrap: break-word; }
        .node-content h1, .node-content h2, .node-content h3, .node-content h4, .node-content h5, .node-content h6 { margin-top: 0.5em; margin-bottom: 0.3em; font-weight: 600; line-height: 1.25; }
        .node-content h1 { font-size: 1.5rem !important; }
        .node-content h2 { font-size: 1.3rem !important; }
        .node-content h3 { font-size: 1.2rem !important; }
        .node-content h4 { font-size: 1.1rem !important; }
        .node-content h5 { font-size: 1.05rem !important; }
        .node-content h6 { font-size: 1rem !important; color: #6c757d !important; }
        .node-content p { margin-bottom: 0.5em; }
        .node-content ul, .node-content ol { padding-left: 1.5em; margin-bottom: 0.5em; }
        .node-content li { margin-bottom: 0.2em; }
        .node-content code { background-color: #f1f3f4; border-radius: 3px; padding: 0.1em 0.3em; font-size: 0.9em; font-family: 'Courier New', monospace; }
        .node-content pre { background-color: #f8f9fa; border: 1px solid #e9ecef; border-radius: 4px; padding: 0.8em; overflow: auto; margin-bottom: 0.8em; }
        .node-content pre code { background: none; padding: 0; }
        .node-content blockquote { border-left: 4px solid #dee2e6; padding-left: 1em; margin-left: 0; color: #6c757d; margin-bottom: 0.8em; }
        .node-content table { border-collapse: collapse; width: 100%; margin-bottom: 0.8em; }
        .node-content table th, .node-content table td { border: 1px solid #dee2e6; padding: 0.3em 0.5em; text-align: left; }
        .node-content table th { background-color: #f8f9fa; font-weight: 600; }
        
        /* ÁßªÂä®Á´ØÂìçÂ∫îÂºèÊ†∑Âºè */
        @media (max-width: 768px) {
            .mobile-sidebar-toggle {
                display: block;
            }
            
            .sidebar {
                position: fixed;
                top: 0;
                left: -100%;
                width: 85%;
                max-width: 300px;
                z-index: 1000;
                transition: left 0.3s ease;
            }
            
            .sidebar.active {
                left: 0;
            }
            
            .editor-container {
                width: 100%;
            }
            
            .node {
                width: 90%;
                max-width: 400px;
            }
            
            .toolbar {
                left: 60px;
            }
            
            .chat-input-container {
                padding: 15px;
            }
            
            .zoom-controls {
                right: 10px;
            }
        }
        
        @media (max-width: 576px) {
            .node {
                width: 95%;
                max-width: 350px;
            }
            
            .toolbar {
                left: 50px;
            }
            
            .zoom-controls {
                right: 5px;
            }
            
            .chat-input-container {
                padding: 10px;
            }
        }
    </style>
</head>
<body>
    <!-- ÁßªÂä®Á´Ø‰æßËæπÊ†èÂàáÊç¢ÊåâÈíÆ -->
    <button class="mobile-sidebar-toggle" id="mobileSidebarToggle">‚ò∞</button>
    <div class="sidebar-backdrop" id="sidebarBackdrop"></div>
    
    <div class="container-fluid">
        <div class="row">
            <div class="col-md-3 sidebar" id="sidebar">
                <div class="p-3">
                    <h3 class="mb-3 vibe-font">VibeChat<sup>(a)</sup></h3>
                    <div class="d-flex mb-2">
                        <button class="btn btn-outline-light btn-sm m-1 flex-fill" id="exportBtn">ÂØºÂá∫</button>
                        <button class="btn btn-outline-light btn-sm m-1 flex-fill" id="importBtn">ÂØºÂÖ•</button>
                    </div>
                    <input type="file" id="importFile" style="display: none;" accept=".json">
                    
                    <div class="api-settings">
                        <div class="accordion" id="apiSettingsAccordion">
                            <div class="accordion-item border-0">
                                <h2 class="accordion-header" id="apiSettingsHeading">
                                    <button class="accordion-button bg-transparent p-2 ps-3 collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#apiSettingsCollapse" aria-expanded="false" aria-controls="apiSettingsCollapse">
                                        <h6 class="mb-0 small">APIËÆæÁΩÆ</h6>
                                    </button>
                                </h2>
                                <div id="apiSettingsCollapse" class="accordion-collapse collapse" aria-labelledby="apiSettingsHeading" data-bs-parent="#apiSettingsAccordion">
                                    <div class="accordion-body p-3">
                                        <div class="form-group">
                                            <label for="apiUrl" class="form-label small">APIÂú∞ÂùÄ</label>
                                            <input type="text" class="form-control form-control-sm" id="apiUrl" value="https://api.deepseek.com/chat/completions">
                                        </div>
                                        <div class="form-group mt-2">
                                            <label for="apiKey" class="form-label small">APIÂØÜÈí•</label>
                                            <input type="password" class="form-control form-control-sm" id="apiKey" placeholder="ËæìÂÖ•APIÂØÜÈí•">
                                        </div>
                                        <div class="form-group mt-2">
                                            <label for="modelName" class="form-label small">Ê®°ÂûãÂêçÁß∞</label>
                                            <input type="text" class="form-control form-control-sm" id="modelName" value="deepseek-chat" placeholder="ËæìÂÖ•Ê®°ÂûãÂêçÁß∞">
                                        </div>
                                        <div class="form-group mt-2">
                                            <label for="temperature" class="form-label small">Ê∏©Â∫¶<small> (0.1-2.0)</small></label>
                                            <input type="number" class="form-control form-control-sm" id="temperature" min="0" max="2" step="0.1" value="1.0">
                                        </div>
                                        <button class="btn btn-outline-dark btn-sm w-100 mt-3" id="testApiBtn">ÊµãËØïËøûÊé•</button>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                    
                    <hr class="bg-light">
                    <div id="treeViewContainer">
                        <ul class="tree-view" id="treeView"></ul>
                    </div>
                </div>
            </div>
            
            <div class="col-md-9 editor-container">
                <div class="toolbar">
                    <div class="btn-group">
                        <button class="btn btn-dark btn-sm" id="clearConversationBtn">üóëÔ∏è</button>
                        <button class="btn btn-danger btn-sm" id="deleteNodeBtn">Âà†Èô§ËäÇÁÇπ</button>
                    </div>
                </div>
                
                <div class="story-canvas-container" id="canvasContainer">
                    <div class="story-canvas" id="storyCanvas">
                        <svg class="connections" id="connections"></svg>
                    </div>
                </div>
                
                <div class="zoom-controls">
                    <div class="btn-group-vertical">
                        <button class="btn btn-light btn-sm" id="zoomInBtn">+</button>
                        <button class="btn btn-light btn-sm" id="zoomOutBtn">-</button>
                        <button class="btn btn-light btn-sm" id="resetZoomBtn">‚Üª</button>
                    </div>
                </div>
                
                <div class="chat-input-container">
                    <div class="input-group">
                        <input type="text" class="form-control" id="userInput" placeholder="ËæìÂÖ•ÊÇ®ÁöÑÈóÆÈ¢ò..." autocomplete="off">
                        <button class="btn btn-primary" id="sendBtn">ÂèëÈÄÅ</button>
                    </div>
                    <small class="form-text text-muted mt-2">
                        ËäÇÁÇπÊï∞Èáè: <span id="contextInfo">1</span>
                    </small>
                </div>
            </div>
        </div>
    </div>

    <script>
        // ÈÖçÁΩÆ marked.js
        marked.setOptions({
            breaks: true,
            gfm: true,
            headerIds: false,
            mangle: false
        });
        
        // Â∫îÁî®Â∏∏Èáè
        const CONSTANTS = {
            HORIZONTAL_SPACING: 300,
            VERTICAL_SPACING: 250,
            NODE_WIDTH: 450,
            NODE_HEIGHT: {
                user: 150,
                assistant: 250,
                system: 150
            }
        };
        
        // Â∫îÁî®Áä∂ÊÄÅ
        const state = {
            conversation: {
                title: "VibeChat",
                nodes: {},
                startNode: null
            },
            selectedNodeId: null,
            zoomLevel: 1,
            isDragging: false,
            dragStart: { x: 0, y: 0 },
            isMobile: window.innerWidth <= 768
        };
        
        // DOM ÂÖÉÁ¥†ÂºïÁî®
        const elements = {
            canvas: document.getElementById('storyCanvas'),
            connections: document.getElementById('connections'),
            treeView: document.getElementById('treeView'),
            contextInfo: document.getElementById('contextInfo'),
            userInput: document.getElementById('userInput'),
            sendBtn: document.getElementById('sendBtn'),
            deleteNodeBtn: document.getElementById('deleteNodeBtn'),
            clearConversationBtn: document.getElementById('clearConversationBtn'),
            sidebar: document.getElementById('sidebar'),
            mobileSidebarToggle: document.getElementById('mobileSidebarToggle'),
            sidebarBackdrop: document.getElementById('sidebarBackdrop')
        };

        // ÂàùÂßãÂåñÂ∫îÁî®
        document.addEventListener('DOMContentLoaded', function() {
            loadStateFromLocalStorage();
            
            if (!state.conversation.startNode || Object.keys(state.conversation.nodes).length === 0) {
                const initialX = (5000 - CONSTANTS.NODE_WIDTH) / 2;
                createNode("system", "‰Ω†ÊòØ‰∏Ä‰∏™ÊúâÁî®ÁöÑAIÂä©Êâã„ÄÇ", initialX, 200, true);
            }
            
            setupEventListeners();
            setupMobileEvents();
            renderAll();
            
            const container = document.getElementById('canvasContainer');
            if (state.selectedNodeId) {
                scrollToNode(state.selectedNodeId);
            } else {
                container.scrollTo(2500 - container.clientWidth / 2, 0);
            }
            
            window.addEventListener('beforeunload', saveStateToLocalStorage);
            window.addEventListener('resize', handleResize);
        });
        
        // ÁßªÂä®Á´Ø‰∫ã‰ª∂ËÆæÁΩÆ
        function setupMobileEvents() {
            if (!state.isMobile) return;
            
            elements.mobileSidebarToggle.addEventListener('click', toggleSidebar);
            elements.sidebarBackdrop.addEventListener('click', closeSidebar);
            
            // ÁÇπÂáªÊ†ëËäÇÁÇπÊó∂Ëá™Âä®ÂÖ≥Èó≠‰æßËæπÊ†è
            elements.treeView.addEventListener('click', function(e) {
                if (e.target.closest('.tree-node')) {
                    setTimeout(closeSidebar, 300);
                }
            });
        }
        
        function toggleSidebar() {
            elements.sidebar.classList.toggle('active');
            elements.sidebarBackdrop.style.display = elements.sidebar.classList.contains('active') ? 'block' : 'none';
        }
        
        function closeSidebar() {
            elements.sidebar.classList.remove('active');
            elements.sidebarBackdrop.style.display = 'none';
        }
        
        function handleResize() {
            state.isMobile = window.innerWidth <= 768;
            
            if (!state.isMobile) {
                closeSidebar();
            }
        }
        
        // ‰∫ã‰ª∂ÁõëÂê¨Âô®ËÆæÁΩÆ
        function setupEventListeners() {
            elements.deleteNodeBtn.addEventListener('click', deleteNode);
            elements.clearConversationBtn.addEventListener('click', clearConversation);
            document.getElementById('exportBtn').addEventListener('click', exportConversation);
            document.getElementById('importBtn').addEventListener('click', () => document.getElementById('importFile').click());
            document.getElementById('importFile').addEventListener('change', importConversation);
            document.getElementById('zoomInBtn').addEventListener('click', () => adjustZoom(0.1));
            document.getElementById('zoomOutBtn').addEventListener('click', () => adjustZoom(-0.1));
            document.getElementById('resetZoomBtn').addEventListener('click', resetZoom);
            elements.sendBtn.addEventListener('click', sendMessage);
            elements.userInput.addEventListener('keypress', e => e.key === 'Enter' && sendMessage());
            document.getElementById('testApiBtn').addEventListener('click', testApiConnection);
            
            // ËäÇÁÇπ‰∫ã‰ª∂ÂßîÊâò
            elements.canvas.addEventListener('click', handleNodeClick);
        }
        
        // ËäÇÁÇπÁÇπÂáª‰∫ã‰ª∂Â§ÑÁêÜ
        function handleNodeClick(e) {
            const nodeElement = e.target.closest('.node');
            if (!nodeElement) return;
            
            const nodeId = nodeElement.id;
            
            if (e.target.classList.contains('reasoning-toggle')) {
                toggleReasoning(nodeId);
                return;
            }
            
            if (e.target.classList.contains('resend-btn')) {
                resendMessage(nodeId);
                return;
            }
            
            if (e.target.classList.contains('copy-btn')) {
                copyNodeContent(nodeId);
                return;
            }
            
            if (e.target.classList.contains('node-content') || 
                e.target.classList.contains('reasoning-content') ||
                e.target.classList.contains('final-answer')) {
                editNodeContent(nodeId);
            } else {
                selectNode(nodeId);
            }
        }
        
        // ËäÇÁÇπÁÆ°ÁêÜÂáΩÊï∞
        function createNode(role, content, x, y, isStart = false, reasoning = null) {
            const id = 'node_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);
            
            state.conversation.nodes[id] = {
                id,
                role,
                content,
                reasoning,
                branches: [],
                position: { x, y }
            };
            
            if (isStart) {
                state.conversation.startNode = id;
                state.selectedNodeId = id;
            }
            
            return id;
        }
        
        function deleteNode() {
            if (!state.selectedNodeId || state.selectedNodeId === state.conversation.startNode) {
                alert('‰∏çËÉΩÂà†Èô§Ëµ∑ÂßãËäÇÁÇπ');
                return;
            }
            
            if (!confirm('Á°ÆÂÆöË¶ÅÂà†Èô§Ëøô‰∏™ËäÇÁÇπÂèäÂÖ∂ÊâÄÊúâÂ≠êËäÇÁÇπÂêóÔºü')) return;
            
            deleteNodeAndChildren(state.selectedNodeId);
            state.selectedNodeId = null;
            renderAll();
            saveStateToLocalStorage();
        }
        
        function deleteNodeAndChildren(nodeId) {
            if (!state.conversation.nodes[nodeId]) return;
            
            state.conversation.nodes[nodeId].branches.forEach(branch => {
                deleteNodeAndChildren(branch.nextNodeId);
            });
            
            Object.values(state.conversation.nodes).forEach(node => {
                node.branches = node.branches.filter(branch => branch.nextNodeId !== nodeId);
            });
            
            delete state.conversation.nodes[nodeId];
        }
        
        function clearConversation() {
            if (!confirm('Á°ÆÂÆöË¶ÅÊ∏ÖÁ©∫ÂØπËØùÂêóÔºüËøôÂ∞ÜÂà†Èô§ÊâÄÊúâËäÇÁÇπÔºåÂè™‰øùÁïôÁ≥ªÁªüÊèêÁ§∫Ê∂àÊÅØ„ÄÇ')) return;
            if (!confirm('ÂÜçÊ¨°Á°ÆËÆ§ÔºöËøôÂ∞ÜÊ∞∏‰πÖÂà†Èô§ÊâÄÊúâÂØπËØùÂÜÖÂÆπÔºåÂè™‰øùÁïôÁ≥ªÁªüËäÇÁÇπ„ÄÇ')) return;
            
            const systemNode = state.conversation.nodes[state.conversation.startNode];
            if (!systemNode) return;
            
            state.conversation.nodes = {};
            state.conversation.nodes[state.conversation.startNode] = systemNode;
            systemNode.branches = [];
            state.selectedNodeId = state.conversation.startNode;
            
            renderAll();
            saveStateToLocalStorage();
            
            alert('ÂØπËØùÂ∑≤Ê∏ÖÁ©∫ÔºåÂè™‰øùÁïôÁ≥ªÁªüÊèêÁ§∫Ê∂àÊÅØ„ÄÇ');
        }
        
        // Ê∂àÊÅØÂèëÈÄÅÂíåAPIË∞ÉÁî®
        async function sendMessage() {
            const userInput = elements.userInput.value.trim();
            if (!userInput) {
                alert('ËØ∑ËæìÂÖ•ÈóÆÈ¢ò');
                return;
            }
            
            if (!state.selectedNodeId) {
                alert('ËØ∑ÂÖàÈÄâÊã©‰∏Ä‰∏™ËäÇÁÇπ');
                return;
            }
            
            const apiUrl = document.getElementById('apiUrl').value.trim();
            const apiKey = document.getElementById('apiKey').value.trim();
            const modelName = document.getElementById('modelName').value.trim() || "deepseek-chat";
            const temperature = parseFloat(document.getElementById('temperature').value) || 1.0;
            
            if (!apiUrl || !apiKey) {
                alert('ËØ∑ËÆæÁΩÆAPIÂú∞ÂùÄÂíåAPIÂØÜÈí•');
                return;
            }
            
            elements.sendBtn.disabled = true;
            elements.userInput.disabled = true;
            elements.sendBtn.textContent = 'ÂèëÈÄÅ‰∏≠...';
            
            try {
                const contextMessages = getContextMessages(state.selectedNodeId);
                contextMessages.push({ role: 'user', content: userInput });
                
                const parentNode = state.conversation.nodes[state.selectedNodeId];
                const userNodePos = calculateNodePosition(parentNode, 'user');
                const newUserNodeId = createNode("user", userInput, userNodePos.x, userNodePos.y);
                
                const assistantNodePos = calculateNodePosition(state.conversation.nodes[newUserNodeId], 'assistant');
                const newAssistantNodeId = createNode("assistant", "", assistantNodePos.x, assistantNodePos.y);
                
                parentNode.branches.push({
                    id: 'branch_' + Date.now(),
                    text: userInput.substring(0, 30) + (userInput.length > 30 ? '...' : ''),
                    nextNodeId: newUserNodeId
                });
                
                state.conversation.nodes[newUserNodeId].branches.push({
                    id: 'branch_' + Date.now(),
                    text: "Âä©ÊâãÂõûÂ§ç",
                    nextNodeId: newAssistantNodeId
                });
                
                state.selectedNodeId = newAssistantNodeId;
                elements.userInput.value = '';
                
                renderAll();
                scrollToNode(newAssistantNodeId);
                
                await callDeepseekAPIStream(apiUrl, apiKey, modelName, temperature, contextMessages, newAssistantNodeId);
                
            } catch (error) {
                console.error('ÂèëÈÄÅÊ∂àÊÅØÂ§±Ë¥•:', error);
                alert('ÂèëÈÄÅÊ∂àÊÅØÂ§±Ë¥•: ' + error.message);
            } finally {
                elements.sendBtn.disabled = false;
                elements.userInput.disabled = false;
                elements.sendBtn.textContent = 'ÂèëÈÄÅ';
                saveStateToLocalStorage();
            }
        }
        
        async function resendMessage(userNodeId) {
            const userNode = state.conversation.nodes[userNodeId];
            if (!userNode || userNode.role !== 'user') {
                alert('Âè™ËÉΩÂú®Áî®Êà∑ËäÇÁÇπ‰∏äÈáçÂèë');
                return;
            }
            
            const apiUrl = document.getElementById('apiUrl').value.trim();
            const apiKey = document.getElementById('apiKey').value.trim();
            const modelName = document.getElementById('modelName').value.trim() || "deepseek-chat";
            const temperature = parseFloat(document.getElementById('temperature').value) || 1.0;
            
            if (!apiUrl || !apiKey) {
                alert('ËØ∑ËÆæÁΩÆAPIÂú∞ÂùÄÂíåAPIÂØÜÈí•');
                return;
            }
            
            const assistantNodePos = calculateNodePosition(userNode, 'assistant');
            const newAssistantNodeId = createNode("assistant", "", assistantNodePos.x, assistantNodePos.y);
            
            userNode.branches.push({
                id: 'branch_' + Date.now(),
                text: "Âä©ÊâãÂõûÂ§ç",
                nextNodeId: newAssistantNodeId
            });
            
            state.selectedNodeId = newAssistantNodeId;
            
            renderAll();
            scrollToNode(newAssistantNodeId);
            
            const contextMessages = getContextMessages(userNodeId);
            
            try {
                await callDeepseekAPIStream(apiUrl, apiKey, modelName, temperature, contextMessages, newAssistantNodeId);
                saveStateToLocalStorage();
            } catch (error) {
                console.error('ÈáçÂèëÊ∂àÊÅØÂ§±Ë¥•:', error);
                alert('ÈáçÂèëÊ∂àÊÅØÂ§±Ë¥•: ' + error.message);
            }
        }
        
        async function callDeepseekAPIStream(apiUrl, apiKey, modelName, temperature, messages, assistantNodeId) {
            const assistantNode = state.conversation.nodes[assistantNodeId];
            
            assistantNode.content = '';
            assistantNode.reasoning = null;
            
            assistantNode.content = '<span class="typing-indicator"></span><span class="typing-indicator"></span><span class="typing-indicator"></span>';
            renderNodes();
            
            try {
                const response = await fetch(apiUrl, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'Authorization': `Bearer ${apiKey}`
                    },
                    body: JSON.stringify({
                        model: modelName,
                        messages,
                        stream: true,
                        temperature: temperature
                    })
                });
                
                if (!response.ok) {
                    throw new Error(`APIËØ∑Ê±ÇÂ§±Ë¥•: ${response.status} ${response.statusText}`);
                }
                
                const reader = response.body.getReader();
                const decoder = new TextDecoder();
                let assistantContent = '';
                let reasoningContent = '';
                let isReasonerModel = false;
                
                while (true) {
                    const { done, value } = await reader.read();
                    if (done) break;
                    
                    const chunk = decoder.decode(value);
                    const lines = chunk.split('\n');
                    
                    for (const line of lines) {
                        if (line.startsWith('data: ') && line !== 'data: [DONE]') {
                            try {
                                const data = JSON.parse(line.slice(6));
                                
                                if (data.choices?.[0]?.delta?.reasoning_content !== undefined) {
                                    isReasonerModel = true;
                                    reasoningContent += data.choices[0].delta.reasoning_content || '';
                                    assistantNode.reasoning = reasoningContent;
                                }
                                
                                if (data.choices?.[0]?.delta?.content) {
                                    assistantContent += data.choices[0].delta.content;
                                    assistantNode.content = assistantContent;
                                }
                                
                                renderNodes();
                            } catch (e) {
                                // ÂøΩÁï•Ëß£ÊûêÈîôËØØ
                            }
                        }
                    }
                }
                
                if (isReasonerModel) {
                    assistantNode.reasoning = reasoningContent;
                    assistantNode.content = assistantContent;
                } else {
                    assistantNode.content = assistantContent;
                }
                
                renderAll();
                
            } catch (error) {
                console.error('ÊµÅÂºèÂìçÂ∫îÈîôËØØ:', error);
                assistantNode.content = 'ÈîôËØØ: ' + error.message;
                renderAll();
            }
        }
        
        async function testApiConnection() {
            const apiUrl = document.getElementById('apiUrl').value.trim();
            const apiKey = document.getElementById('apiKey').value.trim();
            const modelName = document.getElementById('modelName').value.trim() || "deepseek-chat";
            const temperature = parseFloat(document.getElementById('temperature').value) || 1.0;
            
            if (!apiUrl || !apiKey) {
                alert('ËØ∑ËÆæÁΩÆAPIÂú∞ÂùÄÂíåAPIÂØÜÈí•');
                return;
            }
            
            const testBtn = document.getElementById('testApiBtn');
            testBtn.disabled = true;
            testBtn.textContent = 'ÊµãËØï‰∏≠...';
            
            try {
                const response = await fetch(apiUrl, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'Authorization': `Bearer ${apiKey}`
                    },
                    body: JSON.stringify({
                        model: modelName,
                        messages: [
                            { role: 'system', content: '‰Ω†ÊòØ‰∏Ä‰∏™ÊµãËØïÂä©Êâã„ÄÇ' },
                            { role: 'user', content: 'ËØ∑ÂõûÂ§ç"ËøûÊé•ÊàêÂäü"‰ª•Á°ÆËÆ§APIËøûÊé•Ê≠£Â∏∏„ÄÇ' }
                        ],
                        stream: false,
                        temperature: temperature
                    })
                });
                
                if (!response.ok) {
                    throw new Error(`APIËØ∑Ê±ÇÂ§±Ë¥•: ${response.status} ${response.statusText}`);
                }
                
                const data = await response.json();
                
                if (data.choices?.[0]?.message?.content) {
                    alert('APIËøûÊé•ÊàêÂäüÔºÅ');
                } else {
                    alert('APIËøûÊé•ÊµãËØïÂÆåÊàêÔºå‰ΩÜÂìçÂ∫î‰∏çÁ¨¶ÂêàÈ¢ÑÊúü„ÄÇ');
                }
            } catch (error) {
                alert('APIËøûÊé•Â§±Ë¥•: ' + error.message);
            } finally {
                testBtn.disabled = false;
                testBtn.textContent = 'ÊµãËØïËøûÊé•';
            }
        }
        
        // Ê∏≤ÊüìÂáΩÊï∞
        function renderAll() {
            renderNodes();
            renderConnections();
            renderTreeView();
            updateUI();
            updateContextInfo();
        }
        
        function renderNodes() {
            const canvas = elements.canvas;
            const existingNodes = canvas.querySelectorAll('.node');
            const existingNodeIds = new Set(Array.from(existingNodes).map(node => node.id));
            const currentNodeIds = new Set(Object.keys(state.conversation.nodes));
            
            existingNodes.forEach(node => {
                if (!currentNodeIds.has(node.id)) {
                    node.remove();
                }
            });
            
            Object.values(state.conversation.nodes).forEach(node => {
                let nodeElement = document.getElementById(node.id);
                
                if (!nodeElement) {
                    nodeElement = createNodeElement(node);
                    canvas.appendChild(nodeElement);
                    makeDraggable(nodeElement, node);
                } else {
                    updateNodeElement(nodeElement, node);
                }
            });
            
            updateSelection();
        }
        
        function createNodeElement(node) {
            const element = document.createElement('div');
            element.className = `node ${node.role}`;
            element.id = node.id;
            element.style.left = node.position.x + 'px';
            element.style.top = node.position.y + 'px';
            
            const roleIndicator = document.createElement('div');
            roleIndicator.className = `role-indicator role-${node.role}`;
            roleIndicator.textContent = node.role.toUpperCase();
            
            // ‰∏∫Áî®Êà∑ËäÇÁÇπÊ∑ªÂä†ÈáçÂèëÊåâÈíÆ
            if (node.role === 'user') {
                const resendBtn = document.createElement('button');
                resendBtn.className = 'resend-btn mt-1';
                resendBtn.textContent = '‚Üª';
                resendBtn.title = 'ÈáçÂèëÊ≠§Ê∂àÊÅØ';
                resendBtn.dataset.nodeId = node.id;
                element.appendChild(resendBtn);
            }
            
            // ‰∏∫ÊâÄÊúâËäÇÁÇπÊ∑ªÂä†Â§çÂà∂ÊåâÈíÆ
            const copyBtn = document.createElement('button');
            copyBtn.className = 'copy-btn mt-1';
            copyBtn.textContent = '‚éò';
            copyBtn.title = 'Â§çÂà∂ÂÜÖÂÆπ';
            copyBtn.dataset.nodeId = node.id;
            element.appendChild(copyBtn);
            
            const content = document.createElement('div');
            content.className = 'node-content';
            
            if (node.reasoning !== undefined && node.reasoning !== null) {
                const reasoningToggle = document.createElement('div');
                reasoningToggle.className = 'reasoning-toggle';
                reasoningToggle.textContent = '‚áÖ Êé®ÁêÜËøáÁ®ã';
                reasoningToggle.dataset.nodeId = node.id;
                
                const reasoningContent = document.createElement('div');
                reasoningContent.className = 'reasoning-content reasoning-collapsed';
                reasoningContent.dataset.nodeId = node.id;
                
                if (node.reasoning.includes('typing-indicator')) {
                    reasoningContent.innerHTML = node.reasoning;
                } else {
                    reasoningContent.textContent = node.reasoning;
                }
                
                const finalAnswer = document.createElement('div');
                finalAnswer.className = 'final-answer markdown-body';
                finalAnswer.style.marginTop = '8px';
                
                // Âè™Âú®ÊµÅÂºèËæìÂá∫ÂÆåÊàêÂêéÊ∏≤ÊüìMarkdown
                if (node.content.includes('typing-indicator')) {
                    finalAnswer.innerHTML = node.content;
                } else {
                    finalAnswer.innerHTML = marked.parse(node.content);
                }
                
                content.appendChild(reasoningToggle);
                content.appendChild(reasoningContent);
                content.appendChild(finalAnswer);
            } else {
                // Âè™Âú®ÊµÅÂºèËæìÂá∫ÂÆåÊàêÂêéÊ∏≤ÊüìMarkdown
                if (node.content.includes('typing-indicator')) {
                    content.innerHTML = node.content;
                } else {
                    content.innerHTML = marked.parse(node.content);
                }
            }
            
            element.appendChild(roleIndicator);
            element.appendChild(content);
            
            return element;
        }
        
        function updateNodeElement(element, node) {
            const content = element.querySelector('.node-content');
            
            // Á°Æ‰øùÁî®Êà∑ËäÇÁÇπÁöÑÈáçÂèëÊåâÈíÆÂ≠òÂú®
            if (node.role === 'user' && !element.querySelector('.resend-btn')) {
                const resendBtn = document.createElement('button');
                resendBtn.className = 'resend-btn';
                resendBtn.textContent = '‚Üª';
                resendBtn.title = 'ÈáçÂèëÊ≠§Ê∂àÊÅØ';
                resendBtn.dataset.nodeId = node.id;
                element.appendChild(resendBtn);
            }
            
            // Á°Æ‰øùÂ§çÂà∂ÊåâÈíÆÂ≠òÂú®
            if (!element.querySelector('.copy-btn')) {
                const copyBtn = document.createElement('button');
                copyBtn.className = 'copy-btn';
                copyBtn.textContent = '‚éò';
                copyBtn.title = 'Â§çÂà∂ÂÜÖÂÆπ';
                copyBtn.dataset.nodeId = node.id;
                element.appendChild(copyBtn);
            }
            
            if (node.reasoning !== undefined && node.reasoning !== null) {
                let reasoningToggle = content.querySelector('.reasoning-toggle');
                let reasoningContent = content.querySelector('.reasoning-content');
                let finalAnswer = content.querySelector('.final-answer');
                
                if (!reasoningToggle) {
                    content.innerHTML = '';
                    
                    reasoningToggle = document.createElement('div');
                    reasoningToggle.className = 'reasoning-toggle';
                    reasoningToggle.textContent = '‚Üï Êé®ÁêÜËøáÁ®ã';
                    reasoningToggle.dataset.nodeId = node.id;
                    
                    reasoningContent = document.createElement('div');
                    reasoningContent.className = 'reasoning-content reasoning-collapsed';
                    reasoningContent.dataset.nodeId = node.id;
                    
                    finalAnswer = document.createElement('div');
                    finalAnswer.className = 'final-answer markdown-body';
                    finalAnswer.style.marginTop = '8px';
                    
                    content.appendChild(reasoningToggle);
                    content.appendChild(reasoningContent);
                    content.appendChild(finalAnswer);
                }
                
                if (node.reasoning.includes('typing-indicator')) {
                    reasoningContent.innerHTML = node.reasoning;
                } else {
                    reasoningContent.textContent = node.reasoning;
                }
                
                if (node.content.includes('typing-indicator')) {
                    finalAnswer.innerHTML = node.content;
                } else {
                    finalAnswer.innerHTML = marked.parse(node.content);
                }
            } else {
                if (node.content.includes('typing-indicator')) {
                    content.innerHTML = node.content;
                } else {
                    content.innerHTML = marked.parse(node.content);
                }
            }
            
            element.style.left = node.position.x + 'px';
            element.style.top = node.position.y + 'px';
        }
        
        function renderConnections() {
            const svg = elements.connections;
            svg.innerHTML = '';
            
            Object.values(state.conversation.nodes).forEach(node => {
                node.branches.forEach(branch => {
                    const targetNode = state.conversation.nodes[branch.nextNodeId];
                    if (targetNode) drawConnection(svg, node, targetNode);
                });
            });
        }
        
        function drawConnection(svg, fromNode, toNode) {
            const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
            
            const fromY = fromNode.position.y + CONSTANTS.NODE_HEIGHT[fromNode.role];
            const fromX = fromNode.position.x + CONSTANTS.NODE_WIDTH / 2;
            const toX = toNode.position.x + CONSTANTS.NODE_WIDTH / 2;
            const toY = toNode.position.y;
            
            const pathData = `M ${fromX} ${fromY} C ${fromX} ${fromY + 125}, ${toX} ${toY - 125}, ${toX} ${toY}`;
            path.setAttribute('d', pathData);
            
            const pathToSelected = getPathToNode(state.conversation.startNode, state.selectedNodeId);
            const inPath = pathToSelected.includes(fromNode.id) && pathToSelected.includes(toNode.id);
            
            path.setAttribute('stroke', inPath ? '#007bff' : '#6c757d');
            path.setAttribute('stroke-width', inPath ? '2' : '1');
            path.setAttribute('fill', 'none');
            path.setAttribute('stroke-dasharray', inPath ? 'none' : '5,5');
            
            svg.appendChild(path);
        }
        
        function renderTreeView() {
            const treeView = elements.treeView;
            treeView.innerHTML = '';
            
            if (state.conversation.startNode) {
                const treeNode = createTreeNode(state.conversation.startNode);
                treeView.appendChild(treeNode);
            }
        }
        
        function createTreeNode(nodeId) {
            const node = state.conversation.nodes[nodeId];
            if (!node) return null;
            
            const li = document.createElement('li');
            
            const treeNode = document.createElement('div');
            treeNode.className = 'tree-node';
            
            const roleBadge = document.createElement('span');
            roleBadge.className = `badge ${node.role === 'system' ? 'bg-success' : node.role === 'user' ? 'bg-primary' : 'bg-info'} me-1`;
            roleBadge.textContent = node.role.substring(0, 1).toUpperCase();
            
            const content = document.createTextNode(
                node.content.length > 30 ? node.content.substring(0, 30) + '...' : node.content
            );
            
            treeNode.appendChild(roleBadge);
            treeNode.appendChild(content);
            treeNode.dataset.nodeId = nodeId;
            
            treeNode.addEventListener('click', (e) => {
                e.stopPropagation();
                selectNode(nodeId);
                scrollToNode(nodeId);
            });
            
            li.appendChild(treeNode);
            
            if (node.branches.length > 0) {
                const childList = document.createElement('ul');
                
                node.branches.forEach(branch => {
                    const childNode = createTreeNode(branch.nextNodeId);
                    if (childNode) childList.appendChild(childNode);
                });
                
                li.appendChild(childList);
            }
            
            return li;
        }
        
        // Â∑•ÂÖ∑ÂáΩÊï∞
        function calculateNodePosition(parentNode, nodeType) {
            const parentPos = parentNode.position;
            
            const children = Object.values(state.conversation.nodes).filter(node => 
                parentNode.branches.some(branch => branch.nextNodeId === node.id)
            );
            
            let newY = parentPos.y + CONSTANTS.VERTICAL_SPACING;
            let newX = parentPos.x;
            
            if (children.length > 0) {
                const avgX = children.reduce((sum, node) => sum + node.position.x, 0) / children.length;
                newX = avgX + (children.length * CONSTANTS.HORIZONTAL_SPACING);
                
                let attempts = 0;
                while (isOverlapping(newX, newY, nodeType) && attempts < 10) {
                    newX += CONSTANTS.HORIZONTAL_SPACING;
                    attempts++;
                }
            }
            
            return { x: newX, y: newY };
        }
        
        function isOverlapping(x, y, nodeType) {
            const nodeWidth = CONSTANTS.NODE_WIDTH + 20;
            const nodeHeight = CONSTANTS.NODE_HEIGHT[nodeType];
            
            return Object.values(state.conversation.nodes).some(node => {
                const existingNodeHeight = CONSTANTS.NODE_HEIGHT[node.role];
                
                return (
                    x < node.position.x + nodeWidth && 
                    x + nodeWidth > node.position.x && 
                    y < node.position.y + existingNodeHeight && 
                    y + nodeHeight > node.position.y
                );
            });
        }
        
        function getContextMessages(nodeId) {
            const path = getPathToNode(state.conversation.startNode, nodeId);
            return path.map(id => {
                const node = state.conversation.nodes[id];
                return { role: node.role, content: node.content };
            });
        }
        
        function getPathToNode(startNodeId, targetNodeId, path = []) {
            if (!startNodeId) return [];
            
            path.push(startNodeId);
            
            if (startNodeId === targetNodeId) return path;
            
            const node = state.conversation.nodes[startNodeId];
            for (let branch of node.branches) {
                const result = getPathToNode(branch.nextNodeId, targetNodeId, [...path]);
                if (result.length > 0) return result;
            }
            
            return [];
        }
        
        function selectNode(nodeId) {
            state.selectedNodeId = nodeId;
            updateSelection();
            updateUI();
            updateContextInfo();
            renderConnections();
            saveStateToLocalStorage();
        }
        
        function updateSelection() {
            const path = getPathToNode(state.conversation.startNode, state.selectedNodeId);
            
            Object.values(state.conversation.nodes).forEach(node => {
                const element = document.getElementById(node.id);
                if (!element) return;
                
                const inPath = path.includes(node.id);
                
                if (node.id === state.selectedNodeId) {
                    element.classList.add('selected');
                    element.classList.remove('muted');
                } else if (inPath) {
                    element.classList.remove('selected');
                    element.classList.remove('muted');
                } else {
                    element.classList.remove('selected');
                    element.classList.add('muted');
                }
            });
            
            document.querySelectorAll('.tree-node').forEach(treeNode => {
                treeNode.classList.toggle('selected', treeNode.dataset.nodeId === state.selectedNodeId);
            });
        }
        
        function updateUI() {
            const hasSelection = state.selectedNodeId !== null;
            elements.deleteNodeBtn.disabled = !hasSelection;
            elements.sendBtn.disabled = !hasSelection;
        }
        
        function updateContextInfo() {
            if (!state.selectedNodeId) {
                elements.contextInfo.textContent = '0';
                return;
            }
            
            const path = getPathToNode(state.conversation.startNode, state.selectedNodeId);
            elements.contextInfo.textContent = path.length;
        }
        
        function editNodeContent(nodeId) {
            const node = state.conversation.nodes[nodeId];
            
            if (node.reasoning !== undefined && node.reasoning !== null) {
                const newContent = prompt('ÁºñËæëËäÇÁÇπÊúÄÁªàÂõûÁ≠î:', node.content);
                if (newContent !== null) {
                    node.content = newContent;
                    renderAll();
                    saveStateToLocalStorage();
                }
            } else {
                const newContent = prompt('ÁºñËæëËäÇÁÇπÂÜÖÂÆπ:', node.content);
                if (newContent !== null) {
                    node.content = newContent;
                    renderAll();
                    saveStateToLocalStorage();
                }
            }
        }
        
        function toggleReasoning(nodeId) {
            const nodeElement = document.getElementById(nodeId);
            if (!nodeElement) return;
            
            const reasoningContent = nodeElement.querySelector('.reasoning-content');
            if (!reasoningContent) return;
            
            reasoningContent.classList.toggle('reasoning-collapsed');
        }
        
        function copyNodeContent(nodeId) {
            const node = state.conversation.nodes[nodeId];
            if (!node) return;
            
            // ÂØπ‰∫éÂä©ÊâãËäÇÁÇπÔºåÂè™Â§çÂà∂ÊúÄÁªàÁ≠îÊ°àÔºà‰∏çÂåÖÂê´Êé®ÁêÜËøáÁ®ãÔºâ
            let textToCopy = node.content;
            
            // Â¶ÇÊûúËäÇÁÇπÂÜÖÂÆπÂåÖÂê´MarkdownÔºåÊàë‰ª¨ÈúÄË¶ÅËé∑ÂèñÁ∫ØÊñáÊú¨
            // ÂàõÂª∫‰∏Ä‰∏™‰∏¥Êó∂ÂÖÉÁ¥†Êù•ÊèêÂèñÊñáÊú¨
            const tempElement = document.createElement('div');
            if (node.reasoning !== undefined && node.reasoning !== null) {
                // ÂØπ‰∫éÊúâÊé®ÁêÜËøáÁ®ãÁöÑÂä©ÊâãËäÇÁÇπÔºåÂè™Â§çÂà∂ÊúÄÁªàÁ≠îÊ°à
                tempElement.innerHTML = node.content;
            } else {
                tempElement.innerHTML = node.content;
            }
            
            // Ëé∑ÂèñÁ∫ØÊñáÊú¨
            textToCopy = tempElement.textContent || tempElement.innerText || '';
            
            // ‰ΩøÁî®Clipboard APIÂ§çÂà∂ÊñáÊú¨
            navigator.clipboard.writeText(textToCopy).then(() => {
                // ÊòæÁ§∫Â§çÂà∂ÊàêÂäüÊèêÁ§∫
                showCopySuccess(nodeId);
            }).catch(err => {
                console.error('Â§çÂà∂Â§±Ë¥•:', err);
                // Â¶ÇÊûúClipboard API‰∏çÂèØÁî®Ôºå‰ΩøÁî®Â§áÁî®ÊñπÊ≥ï
                const textArea = document.createElement('textarea');
                textArea.value = textToCopy;
                document.body.appendChild(textArea);
                textArea.select();
                document.execCommand('copy');
                document.body.removeChild(textArea);
                showCopySuccess(nodeId);
            });
        }
        
        function showCopySuccess(nodeId) {
            const nodeElement = document.getElementById(nodeId);
            if (!nodeElement) return;
            
            // Ê£ÄÊü•ÊòØÂê¶Â∑≤Â≠òÂú®ÊàêÂäüÊèêÁ§∫
            let successElement = nodeElement.querySelector('.copy-success');
            if (!successElement) {
                successElement = document.createElement('div');
                successElement.className = 'copy-success mt-1';
                successElement.textContent = 'Â§çÂà∂ÊàêÂäü';
                nodeElement.appendChild(successElement);
            }
            
            // ÊòæÁ§∫ÊàêÂäüÊèêÁ§∫
            successElement.classList.add('show');
            
            // 2ÁßíÂêéÈöêËóèÊàêÂäüÊèêÁ§∫
            setTimeout(() => {
                successElement.classList.remove('show');
            }, 2000);
        }
        
        function makeDraggable(element, node) {
            element.addEventListener('mousedown', startDrag);
            
            function startDrag(e) {
                if (e.target.classList.contains('node-content') || 
                    e.target.classList.contains('reasoning-content') ||
                    e.target.classList.contains('final-answer') ||
                    e.target.classList.contains('reasoning-toggle') ||
                    e.target.classList.contains('resend-btn') ||
                    e.target.classList.contains('copy-btn')) return;
                
                state.isDragging = true;
                state.dragStart.x = e.clientX;
                state.dragStart.y = e.clientY;
                const initialX = element.offsetLeft;
                const initialY = element.offsetTop;
                
                function drag(e) {
                    if (!state.isDragging) return;
                    
                    const dx = e.clientX - state.dragStart.x;
                    const dy = e.clientY - state.dragStart.y;
                    
                    const newX = initialX + dx;
                    const newY = initialY + dy;
                    
                    element.style.left = newX + 'px';
                    element.style.top = newY + 'px';
                    
                    node.position.x = newX;
                    node.position.y = newY;
                    
                    renderConnections();
                }
                
                function stopDrag() {
                    state.isDragging = false;
                    document.removeEventListener('mousemove', drag);
                    document.removeEventListener('mouseup', stopDrag);
                    saveStateToLocalStorage();
                }
                
                document.addEventListener('mousemove', drag);
                document.addEventListener('mouseup', stopDrag);
                
                e.preventDefault();
            }
        }
        
        function scrollToNode(nodeId) {
            const nodeElement = document.getElementById(nodeId);
            if (!nodeElement) return;
            
            const node = state.conversation.nodes[nodeId];
            const nodeX = node.position.x + CONSTANTS.NODE_WIDTH / 2;
            const nodeY = node.position.y + CONSTANTS.NODE_HEIGHT[node.role] / 2;
            const container = document.getElementById('canvasContainer');
            
            const scrollX = nodeX * state.zoomLevel - container.clientWidth / 2;
            const scrollY = nodeY * state.zoomLevel - container.clientHeight / 2;
            
            container.scrollTo(scrollX, scrollY);
        }
        
        function adjustZoom(delta) {
            state.zoomLevel = Math.max(0.3, Math.min(3, state.zoomLevel + delta));
            elements.canvas.style.transform = `scale(${state.zoomLevel})`;
            renderConnections();
        }
        
        function resetZoom() {
            state.zoomLevel = 1;
            elements.canvas.style.transform = 'scale(1)';
            renderConnections();
        }
        
        // Êï∞ÊçÆÊåÅ‰πÖÂåñ
        function saveStateToLocalStorage() {
            try {
                const stateToSave = {
                    conversation: state.conversation,
                    selectedNodeId: state.selectedNodeId,
                    zoomLevel: state.zoomLevel,
                    apiSettings: {
                        apiUrl: document.getElementById('apiUrl').value,
                        apiKey: document.getElementById('apiKey').value,
                        modelName: document.getElementById('modelName').value,
                        temperature: document.getElementById('temperature').value
                    }
                };
                
                localStorage.setItem('vibechat-state', JSON.stringify(stateToSave));
            } catch (error) {
                console.error('‰øùÂ≠òÂà∞localStorageÂ§±Ë¥•:', error);
            }
        }
        
        function loadStateFromLocalStorage() {
            try {
                const savedState = localStorage.getItem('vibechat-state');
                if (savedState) {
                    const parsedState = JSON.parse(savedState);
                    
                    if (parsedState.conversation) {
                        state.conversation = parsedState.conversation;
                    }
                    
                    if (parsedState.selectedNodeId) {
                        state.selectedNodeId = parsedState.selectedNodeId;
                    }
                    
                    if (parsedState.zoomLevel) {
                        state.zoomLevel = parsedState.zoomLevel;
                        elements.canvas.style.transform = `scale(${state.zoomLevel})`;
                    }
                    
                    if (parsedState.apiSettings) {
                        document.getElementById('apiUrl').value = parsedState.apiSettings.apiUrl || 'https://api.deepseek.com/chat/completions';
                        document.getElementById('apiKey').value = parsedState.apiSettings.apiKey || '';
                        document.getElementById('modelName').value = parsedState.apiSettings.modelName || 'deepseek-chat';
                        document.getElementById('temperature').value = parsedState.apiSettings.temperature || '1.0';
                    }
                }
            } catch (error) {
                console.error('‰ªélocalStorageÊÅ¢Â§çÁä∂ÊÄÅÂ§±Ë¥•:', error);
            }
        }
        
        function exportConversation() {
            const now = new Date();
            const timestamp = `${now.getFullYear()}${(now.getMonth()+1).toString().padStart(2, '0')}${now.getDate().toString().padStart(2, '0')}_${now.getHours().toString().padStart(2, '0')}${now.getMinutes().toString().padStart(2, '0')}${now.getSeconds().toString().padStart(2, '0')}`;
            
            const exportData = {
                title: `VibeChat_${timestamp}`,
                nodes: {},
                startNode: state.conversation.startNode
            };
            
            Object.values(state.conversation.nodes).forEach(node => {
                exportData.nodes[node.id] = {
                    id: node.id,
                    role: node.role,
                    content: node.content,
                    reasoning: node.reasoning,
                    branches: node.branches
                };
            });
            
            const dataStr = JSON.stringify(exportData, null, 2);
            const dataBlob = new Blob([dataStr], {type: 'application/json'});
            
            const link = document.createElement('a');
            link.href = URL.createObjectURL(dataBlob);
            link.download = `VibeChat_${timestamp}.json`;
            link.click();
        }
        
        function importConversation(event) {
            const file = event.target.files[0];
            if (!file) return;
            
            const reader = new FileReader();
            reader.onload = function(e) {
                try {
                    const importedData = JSON.parse(e.target.result);
                    
                    if (importedData.nodes && importedData.startNode) {
                        state.conversation = {
                            title: importedData.title || 'VibeChat',
                            nodes: {},
                            startNode: importedData.startNode
                        };
                        
                        Object.values(importedData.nodes).forEach(node => {
                            state.conversation.nodes[node.id] = {
                                id: node.id,
                                role: node.role || 'user',
                                content: node.content,
                                reasoning: node.reasoning,
                                branches: node.branches,
                                position: { x: 0, y: 0 }
                            };
                        });
                        
                        autoArrangeNodes();
                        state.selectedNodeId = null;
                        renderAll();
                        saveStateToLocalStorage();
                        
                        alert('ÂØπËØùÂØºÂÖ•ÊàêÂäüÔºÅ');
                    } else {
                        alert('Êó†ÊïàÁöÑÂØπËØùÊñá‰ª∂Ê†ºÂºè');
                    }
                } catch (error) {
                    alert('ÂØºÂÖ•Â§±Ë¥•Ôºö' + error.message);
                }
                
                event.target.value = '';
            };
            reader.readAsText(file);
        }
        
        function autoArrangeNodes() {
            if (!state.conversation.startNode) return;
            
            const queue = [{nodeId: state.conversation.startNode, depth: 0}];
            const visited = new Set();
            const depthMap = {};
            
            while (queue.length > 0) {
                const {nodeId, depth} = queue.shift();
                
                if (visited.has(nodeId)) continue;
                visited.add(nodeId);
                
                if (!depthMap[depth]) depthMap[depth] = [];
                depthMap[depth].push(nodeId);
                
                const node = state.conversation.nodes[nodeId];
                node.branches.forEach(branch => {
                    queue.push({nodeId: branch.nextNodeId, depth: depth + 1});
                });
            }
            
            const maxDepth = Math.max(...Object.keys(depthMap).map(Number));
            
            for (let depth = 0; depth <= maxDepth; depth++) {
                const nodesAtDepth = depthMap[depth] || [];
                const count = nodesAtDepth.length;
                
                const startX = 2500 - (count * CONSTANTS.HORIZONTAL_SPACING) / 2;
                
                nodesAtDepth.forEach((nodeId, index) => {
                    state.conversation.nodes[nodeId].position = {
                        x: startX + index * CONSTANTS.HORIZONTAL_SPACING,
                        y: 200 + depth * CONSTANTS.VERTICAL_SPACING
                    };
                });
            }
        }
    </script>
</body>
</html>
